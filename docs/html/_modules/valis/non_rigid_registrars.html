

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>valis.non_rigid_registrars &mdash; valis &#34;1.0.0rc11&#34;
 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: black" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/valis_logo_black_no_bg.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../registration.html">Registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../slide_io.html">Slide I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../preprocessing.html">Image pre-processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../feature_detectors.html">Feature detectors and descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../feature_matcher.html">Feature matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../affine_optimizer.html">Affine optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../non_rigid_registrars.html">Non-rigid registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../serial_rigid.html">Serial rigid registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../serial_non_rigid.html">Serial non-rigid registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../viz.html">Visualization</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">valis</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>valis.non_rigid_registrars</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for valis.non_rigid_registrars</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Perform non-rigid registration</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">SimpleITK</span> <span class="k">as</span> <span class="nn">sitk</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">transform</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">color</span> <span class="k">as</span> <span class="n">skcolor</span>
<span class="kn">import</span> <span class="nn">pyvips</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span><span class="p">,</span> <span class="n">parallel_backend</span>

<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">viz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">warp_tools</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">preprocessing</span>

<span class="n">NR_CLS_KEY</span> <span class="o">=</span> <span class="s2">&quot;non_rigid_registrar_cls&quot;</span>
<span class="n">NR_PROCESSING_KW_KEY</span> <span class="o">=</span> <span class="s2">&quot;processing_kwargs&quot;</span>
<span class="n">NR_PROCESSING_CLASS_KEY</span> <span class="o">=</span> <span class="s2">&quot;processing_cls&quot;</span>
<span class="n">NR_STATS_KEY</span> <span class="o">=</span> <span class="s2">&quot;target_stats&quot;</span>
<span class="n">NR_TILE_WH_KEY</span> <span class="o">=</span> <span class="s2">&quot;tile_wh&quot;</span>
<span class="n">NR_PARAMS_KEY</span> <span class="o">=</span> <span class="s2">&quot;params&quot;</span>
<span class="c1"># Abstract Classes #</span>
<div class="viewcode-block" id="NonRigidRegistrar"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrar">[docs]</a><span class="k">class</span> <span class="nc">NonRigidRegistrar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class for non-rigid registration using displacement fields</span>

<span class="sd">    Warps moving_img to align with fixed_img using backwards transformations</span>
<span class="sd">    VALIS offers 3 implementations: dense optical flow (OpenCV),</span>
<span class="sd">    SimpleElastix, and  groupwise SimpleElastix.</span>
<span class="sd">    Displacement fields can come from other packages, indluding</span>
<span class="sd">    SimpleITK, PIRT, DIPY, etc... Those other methods can be used by</span>
<span class="sd">    subclassing the NonRigidRegistrar classes in VALIS.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    moving_img : ndarray</span>
<span class="sd">        Image with shape (N,M) thata is  warp to align with `fixed_img`.</span>

<span class="sd">    fixed_img : ndarray</span>
<span class="sd">        Image with shape (N,M) that `moving_img` is warped to align with.</span>

<span class="sd">    mask : ndarray</span>
<span class="sd">        2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">        and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">        then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">    shape : tuple</span>
<span class="sd">        Number of rows and columns in each image. Will be (N,M).</span>

<span class="sd">    grid_spacing : int</span>
<span class="sd">        Number of pixels between deformation grid points.</span>

<span class="sd">    warped_image : ndarray</span>
<span class="sd">        Registered copy of `moving_img`.</span>

<span class="sd">    deformation_field_img : ndarray</span>
<span class="sd">        Image showing deformation applied to a regular grid.</span>

<span class="sd">    backward_dx : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the x-dimension.</span>

<span class="sd">    backward_dy : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the y-dimension.</span>

<span class="sd">    method : str</span>
<span class="sd">        Name of registration method.</span>

<span class="sd">    Note</span>
<span class="sd">    -----</span>
<span class="sd">    All NonRigidRegistrar subclasses need to have a calc() method,</span>
<span class="sd">    which must at least take the following arguments:</span>
<span class="sd">    moving_img, fixed_img, mask. calc() should return the displacement field</span>
<span class="sd">    as a (2, N, M) numpy array, with the first element being an array of</span>
<span class="sd">    displacements in the x-dimension, and the second element being an array of</span>
<span class="sd">    displacements in the y-dimension.</span>

<span class="sd">    Note that the NonRigidRegistrarXY subclass should be used if</span>
<span class="sd">    corresponding points in moving and fixed images can be used</span>
<span class="sd">    to aid the registration.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NonRigidRegistrar.__init__"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrar.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : dictionary</span>
<span class="sd">            Keyword: value dictionary of parameters to be used in reigstration.</span>
<span class="sd">            Will get used in the calc() method.</span>

<span class="sd">            In the case where simple ITK will be used, params should be</span>
<span class="sd">            a SimpleITK.ParameterMap. Note that numeric values needd to be</span>
<span class="sd">            converted to strings.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warped_image</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deformation_field_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backward_dx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backward_dy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_params_provided</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Empty kwargs dictionary</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_params_provided</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params_provided</span> <span class="o">=</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="nf">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="n">masked_moving</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">masked_fixed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">masked_moving</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">masked_moving</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">masked_moving</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">masked_moving</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">masked_fixed</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">masked_fixed</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">masked_fixed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">masked_fixed</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">masked_moving</span><span class="p">,</span> <span class="n">masked_fixed</span>

<div class="viewcode-block" id="NonRigidRegistrar.calc"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrar.calc">[docs]</a>    <span class="k">def</span> <span class="nf">calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cacluate displacement fields</span>

<span class="sd">        Can record subclass specific atrributes here too</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moving_img : ndarray</span>
<span class="sd">            Image to warp to align with `fixed_img`. Has shape (N, M).</span>

<span class="sd">        fixed_img : ndarray</span>
<span class="sd">            Image `moving_img` is warped to align with. Has shape (N, M).</span>

<span class="sd">        mask : ndarray</span>
<span class="sd">            2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">            and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">            then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bk_dxdy : ndarray</span>
<span class="sd">            (2, N, M) numpy array of pixel displacements in</span>
<span class="sd">            the x and y directions. dx = bk_dxdy[0], and dy=bk_dxdy[1].</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">bk_dxdy</span></div>

    <span class="k">def</span> <span class="nf">create_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">temp_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">img_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">img_list</span><span class="p">:</span>
            <span class="n">temp_mask</span><span class="p">[</span><span class="n">img</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">bbox2mask</span><span class="p">(</span><span class="o">*</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span>
                                    <span class="n">warp_tools</span><span class="o">.</span><span class="n">mask2xy</span><span class="p">(</span><span class="n">temp_mask</span><span class="p">)),</span>
                                    <span class="n">temp_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mask</span>

<div class="viewcode-block" id="NonRigidRegistrar.register"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrar.register">[docs]</a>    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register images, warping moving_img to align with fixed_img</span>

<span class="sd">        Uses backwards transforms to register images (i.e. aligning</span>
<span class="sd">        fixed to moving), so the inverse transform needs to be used</span>
<span class="sd">        to warp points from moving_img. This is automatically done in</span>
<span class="sd">        warp_tools.warp_xy</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moving_img : ndarray</span>
<span class="sd">            Image to warp to align with `fixed_img`.</span>

<span class="sd">        fixed_img : ndarray</span>
<span class="sd">            Image `moving_img` is warped to align with.</span>

<span class="sd">        mask : ndarray</span>
<span class="sd">            2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">            and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">            then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to NonRigidRegistrar.calc</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        warped_img : ndarray</span>
<span class="sd">            Moving image registered to align with fixed image.</span>

<span class="sd">        warped_grid : ndarray</span>
<span class="sd">            Image showing deformation applied to a regular grid.</span>

<span class="sd">        bk_dxdy : ndarray</span>
<span class="sd">            (2, N, M) numpy array of pixel displacements in</span>
<span class="sd">            the x and y directions.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">moving_img</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">fixed_img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>\
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Images have differernt shapes&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">moving_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span> <span class="o">=</span> <span class="n">moving_img</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span> <span class="o">=</span> <span class="n">fixed_img</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">255</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Only do registration inside mask #</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">masked_fixed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">masked_moving</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">mask_bbox</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">mask2xy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">))</span>
            <span class="n">min_c</span><span class="p">,</span> <span class="n">min_r</span> <span class="o">=</span> <span class="n">mask_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">max_c</span><span class="p">,</span> <span class="n">max_r</span> <span class="o">=</span> <span class="n">mask_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">mask_bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span>
            <span class="n">masked_moving</span> <span class="o">=</span> <span class="n">masked_moving</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span>
            <span class="n">masked_fixed</span> <span class="o">=</span> <span class="n">masked_fixed</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">masked_moving</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">masked_fixed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">moving_img</span><span class="o">=</span><span class="n">masked_moving</span><span class="p">,</span>
                            <span class="n">fixed_img</span><span class="o">=</span><span class="n">masked_fixed</span><span class="p">,</span>
                            <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bk_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">bk_dx</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">bk_dxdy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">bk_dx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">bk_dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">bk_dy</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">bk_dxdy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">bk_dy</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bk_dx</span><span class="p">,</span> <span class="n">bk_dy</span><span class="p">])</span>

        <span class="n">warped_img</span><span class="p">,</span> <span class="n">warp_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_warped_img_and_grid</span><span class="p">(</span><span class="n">bk_dxdy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">backward_dx</span> <span class="o">=</span> <span class="n">bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backward_dy</span> <span class="o">=</span> <span class="n">bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deformation_field_img</span> <span class="o">=</span> <span class="n">warp_grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warped_image</span> <span class="o">=</span> <span class="n">warped_img</span>

        <span class="k">return</span> <span class="n">warped_img</span><span class="p">,</span> <span class="n">warp_grid</span><span class="p">,</span> <span class="n">bk_dxdy</span></div>

    <span class="k">def</span> <span class="nf">get_grid_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">grid_spacing_ratio</span><span class="o">=</span><span class="mf">0.025</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an image of a regular grid.</span>

<span class="sd">        Usually used to visualize non-rigid deformations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid_spacing : int, optional</span>
<span class="sd">            Number of pixels between grid points.</span>

<span class="sd">        thickness : int, optional</span>
<span class="sd">            Thickness of lines in image.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">grid_spacing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">grid_spacing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grid_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">grid_spacing_ratio</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">grid_r</span><span class="p">,</span> <span class="n">grid_c</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">get_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
                                      <span class="n">grid_spacing</span><span class="o">=</span><span class="n">grid_spacing</span><span class="p">,</span>
                                      <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">)</span>

        <span class="n">grid_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">grid_img</span><span class="p">[</span><span class="n">grid_r</span><span class="p">,</span> <span class="n">grid_c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>

        <span class="k">return</span> <span class="n">grid_img</span>

    <span class="k">def</span> <span class="nf">get_warped_img_and_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bk_dxdy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply deformation to moving image and regular grid</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bk_dxdy : ndarray</span>
<span class="sd">            (2, N, M) numpy array of pixel displacements in</span>
<span class="sd">            the x and y directions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        warped_img : ndarray</span>
<span class="sd">            Warped copy of moving image.</span>

<span class="sd">        warp_grid : ndarray</span>
<span class="sd">            Image showing deformation applied to regular grid.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">warp_map</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_warp_map</span><span class="p">(</span><span class="n">dxdy</span><span class="o">=</span><span class="n">bk_dxdy</span><span class="p">)</span>
        <span class="n">warped_img</span> <span class="o">=</span><span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span><span class="p">,</span> <span class="n">warp_map</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warped_image</span> <span class="o">=</span> <span class="n">warped_img</span>
        <span class="n">grid_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_image</span><span class="p">(</span><span class="n">grid_spacing</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
        <span class="n">warp_grid</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">grid_img</span><span class="p">,</span> <span class="n">warp_map</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">warped_img</span><span class="p">,</span> <span class="n">warp_grid</span></div>


<div class="viewcode-block" id="NonRigidRegistrarXY"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrarXY">[docs]</a><span class="k">class</span> <span class="nc">NonRigidRegistrarXY</span><span class="p">(</span><span class="n">NonRigidRegistrar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class for non-rigid registration using displacement fields</span>

<span class="sd">    Subclass of NonRigidRegistrar that can (optionally) use corresponding</span>
<span class="sd">    points (xy coordinates) to aid in the registration</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    moving_img : ndarray</span>
<span class="sd">        Image with shape (N,M) thata is  warp to align with `fixed_img`.</span>

<span class="sd">    fixed_img : ndarray</span>
<span class="sd">        Image with shape (N,M) that `moving_img` is warped to align with.</span>

<span class="sd">    mask : ndarray</span>
<span class="sd">        2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">        and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">        then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">    shape : tuple</span>
<span class="sd">        Number of rows and columns in each image. Will be (N,M).</span>

<span class="sd">    grid_spacing : int</span>
<span class="sd">        Number of pixels between deformation grid points/</span>

<span class="sd">    warped_image : ndarray</span>
<span class="sd">        Registered copy of `moving_img`.</span>

<span class="sd">    deformation_field_img : ndarray</span>
<span class="sd">        Image showing deformation applied to a regular grid.</span>

<span class="sd">    backward_dx : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the x-dimension.</span>

<span class="sd">    backward_dy : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the y-dimension.</span>

<span class="sd">    method : str</span>
<span class="sd">        Name of registration method.</span>

<span class="sd">    moving_xy : ndarray, optional</span>
<span class="sd">        (N, 2) array containing points in `moving_img` that correspond</span>
<span class="sd">        to those in the fixed image.</span>

<span class="sd">    fixed_xy : ndarray, optional</span>
<span class="sd">        (N, 2) array containing points in `fixed_img` that correspond</span>
<span class="sd">        to those in the moving image.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    All NonRigidRegistrarXY subclasses need to have a calc() method,</span>
<span class="sd">    which needs to at least take the following arguments:</span>
<span class="sd">    moving_img, fixed_img, mask, moving_xy, fixed_xy.</span>
<span class="sd">    calc() should return the warped moving image, warped regular grid,</span>
<span class="sd">    and the displacement field as an (2, N, M) numpy array.</span>

<span class="sd">    Note that NonRigidRegistrar should be used if corresponding points in</span>
<span class="sd">    moving and fixed images can not be used to aid the registration.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NonRigidRegistrarXY.__init__"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrarXY.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : dictionary</span>
<span class="sd">            Keyword: value dictionary of parameters to be used in reigstration.</span>
<span class="sd">            Will get used in the calc() method.</span>

<span class="sd">            In the case where simple ITK will be used, params should be</span>
<span class="sd">            a SimpleITK.ParameterMap. Note that numeric values needd to be</span>
<span class="sd">            converted to strings.</span>

<span class="sd">        moving_xy : ndarray, optional</span>
<span class="sd">            (N, 2) array containing points in the moving image that correspond</span>
<span class="sd">            to those in the fixed image.</span>

<span class="sd">        fixed_xy : ndarray, optional</span>
<span class="sd">            (N, 2) array containing points in the fixed image that correspond</span>
<span class="sd">            to those in the moving image.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">moving_xy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_xy</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="NonRigidRegistrarXY.register"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrarXY.register">[docs]</a>    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">moving_xy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">fixed_xy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register images, warping moving_img to align with fixed_img</span>

<span class="sd">        Uses backwards transforms to register images (i.e. aligning</span>
<span class="sd">        fixed to moving), so the inverse transform needs to be used</span>
<span class="sd">        to warp points from moving_img. This is automatically done in</span>
<span class="sd">        warp_tools.warp_xy</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moving_img : ndarray</span>
<span class="sd">            Image to warp to align with `fixed_img`.</span>

<span class="sd">        fixed_img : ndarray</span>
<span class="sd">            Image `moving_img` is warped to align with.</span>

<span class="sd">        mask : ndarray</span>
<span class="sd">            2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">            and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">            then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">        moving_xy : ndarray, optional</span>
<span class="sd">            (N, 2) array containing points in the `moving_img` that correspond</span>
<span class="sd">            to those in `fixed_img`.</span>

<span class="sd">        fixed_xy : ndarray, optional</span>
<span class="sd">            (N, 2) array containing points in the `fixed_img` that correspond</span>
<span class="sd">            to those in the `moving_img`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        warped_img : ndarray</span>
<span class="sd">            `moving_img` registered to align with `fixed_img`.</span>

<span class="sd">        warped_grid : ndarray</span>
<span class="sd">            Image showing deformation applied to a regular grid.</span>

<span class="sd">        bk_dxdy : ndarray</span>
<span class="sd">            (2, N, M) numpy array of pixel displacements in the</span>
<span class="sd">            x and y directions.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">moving_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">moving_xy</span><span class="p">,</span> <span class="n">fixed_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_xy</span><span class="p">(</span><span class="n">moving_xy</span><span class="p">,</span> <span class="n">fixed_xy</span><span class="p">,</span>
                                                 <span class="n">moving_img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                 <span class="n">mask</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">moving_xy</span> <span class="o">=</span> <span class="n">moving_xy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_xy</span> <span class="o">=</span> <span class="n">fixed_xy</span>
        <span class="n">warped_img</span><span class="p">,</span> <span class="n">warp_grid</span><span class="p">,</span> <span class="n">bk_dxdy</span> <span class="o">=</span> \
            <span class="n">NonRigidRegistrar</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="o">=</span><span class="n">moving_img</span><span class="p">,</span>
                                       <span class="n">fixed_img</span><span class="o">=</span><span class="n">fixed_img</span><span class="p">,</span>
                                       <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                                       <span class="n">moving_xy</span><span class="o">=</span><span class="n">moving_xy</span><span class="p">,</span>
                                       <span class="n">fixed_xy</span><span class="o">=</span><span class="n">fixed_xy</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">warped_img</span><span class="p">,</span> <span class="n">warp_grid</span><span class="p">,</span> <span class="n">bk_dxdy</span></div>

    <span class="k">def</span> <span class="nf">filter_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_xy</span><span class="p">,</span> <span class="n">fixed_xy</span><span class="p">,</span> <span class="n">img_shape_rc</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove points outside image and/or mask</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">img_shape_rc</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="n">moving_inside_idx</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_inside_mask_idx</span><span class="p">(</span><span class="n">moving_xy</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="n">fixed_inside_idx</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_inside_mask_idx</span><span class="p">(</span><span class="n">fixed_xy</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="n">inside_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">moving_inside_idx</span><span class="p">,</span> <span class="n">fixed_inside_idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">moving_xy</span><span class="p">[</span><span class="n">inside_idx</span><span class="p">,</span> <span class="p">:],</span> <span class="n">fixed_xy</span><span class="p">[</span><span class="n">inside_idx</span><span class="p">,</span> <span class="p">:]</span></div>


<div class="viewcode-block" id="NonRigidRegistrarGroupwise"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrarGroupwise">[docs]</a><span class="k">class</span> <span class="nc">NonRigidRegistrarGroupwise</span><span class="p">(</span><span class="n">NonRigidRegistrar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Performs groupwise non-rigid registration</span>

<span class="sd">    This subclass can register a collection (&gt;= 2) of images,</span>
<span class="sd">    and so is not limited to pairs of images.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    img_list : list of ndarray</span>
<span class="sd">        List of images, each with shape (N,M) that are to be co-registered</span>

<span class="sd">    mask : ndarray</span>
<span class="sd">        2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">        and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">        then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">    shape : tuple of int</span>
<span class="sd">        Number of rows and columns in each image. Will be (N,M).</span>

<span class="sd">    warped_image : ndarray</span>
<span class="sd">        Registered copy of `moving_img`.</span>

<span class="sd">    deformation_field_img : ndarray</span>
<span class="sd">        Image showing deformation applied to a regular grid.</span>

<span class="sd">    backward_dx : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the x-dimension.</span>

<span class="sd">    backward_dy : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the y-dimension.</span>

<span class="sd">    grid_spacing : int</span>
<span class="sd">        Number of pixels between deformation grid points</span>

<span class="sd">    method : str</span>
<span class="sd">        Name of registration method.</span>

<span class="sd">    size : int</span>
<span class="sd">        Number of images that are being registered as a group</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="NonRigidRegistrarGroupwise.__init__"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrarGroupwise.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span></div>

    <span class="k">def</span> <span class="nf">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply mask to all images in img_list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_list</span><span class="p">:</span>
            <span class="n">img</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">create_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">temp_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_list</span><span class="p">:</span>
            <span class="n">temp_mask</span><span class="p">[</span><span class="n">img</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">bbox2mask</span><span class="p">(</span><span class="o">*</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span>
                                    <span class="n">warp_tools</span><span class="o">.</span><span class="n">mask2xy</span><span class="p">(</span><span class="n">temp_mask</span><span class="p">)),</span>
                                    <span class="n">temp_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask</span>

<div class="viewcode-block" id="NonRigidRegistrarGroupwise.register"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.NonRigidRegistrarGroupwise.register">[docs]</a>    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img_list</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register images in img_list</span>

<span class="sd">        Uses backwards transforms to register images (i.e. aligning</span>
<span class="sd">        fixed to moving), so the inverse transform needs to be used</span>
<span class="sd">        to warp points from moving_img. This is automatically done in</span>
<span class="sd">        warp_tools.warp_xy</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        img_list : list of ndarray</span>
<span class="sd">            List of I images, each with shape (N,M) that are to</span>
<span class="sd">            be co-registered.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        warped_img : list of ndarray</span>
<span class="sd">            List of moving images registered to align with the fixed image.</span>

<span class="sd">        warped_grid : list of ndarray</span>
<span class="sd">            Image showing deformation applied to a regular grid.</span>

<span class="sd">        bk_dxdy : list of ndarray</span>
<span class="sd">            List numpy array of pixel displacements in the x and y directions</span>
<span class="sd">            for each image. Has shape (I, N, M, 2).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">img_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">img_list</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Images have differernt shapes&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">img_list</span> <span class="o">=</span> <span class="n">img_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">img_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">255</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uiint8</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">mask_bbox</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">mask2xy</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
            <span class="n">min_c</span><span class="p">,</span> <span class="n">min_r</span> <span class="o">=</span> <span class="n">mask_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">max_c</span><span class="p">,</span> <span class="n">max_r</span> <span class="o">=</span> <span class="n">mask_bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">mask_bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span>
            <span class="n">temp_img_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_list</span><span class="p">):</span>

                <span class="n">temp_img_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp_img_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_list</span>

        <span class="n">backward_deformations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">temp_img_list</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">temp_backward_deformations</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">bk_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">bk_dx</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">backward_deformations</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bk_dx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">bk_dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">bk_dy</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span> <span class="o">=</span> <span class="n">backward_deformations</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">bk_dy</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">temp_backward_deformations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bk_dx</span><span class="p">,</span> <span class="n">bk_dy</span><span class="p">])</span>

            <span class="n">backward_deformations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">temp_backward_deformations</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">backward_dx</span> <span class="o">=</span> <span class="n">backward_deformations</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backward_dy</span> <span class="o">=</span> <span class="n">backward_deformations</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">n_imgs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_list</span><span class="p">)</span>
        <span class="n">warp_maps</span> <span class="o">=</span> <span class="p">[</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">get_warp_map</span><span class="p">(</span><span class="n">dxdy</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">backward_dx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">backward_dy</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_imgs</span><span class="p">)]</span>

        <span class="n">warped_imgs</span> <span class="o">=</span> <span class="p">[</span><span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">img_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">warp_maps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_imgs</span><span class="p">)]</span>

        <span class="n">grid_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_image</span><span class="p">(</span><span class="n">grid_spacing</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
        <span class="n">warped_grids</span> <span class="o">=</span> <span class="p">[</span><span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">grid_img</span><span class="p">,</span> <span class="n">warp_maps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_imgs</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">warped_image</span> <span class="o">=</span> <span class="n">warped_imgs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deformation_field_img</span> <span class="o">=</span> <span class="n">warped_grids</span>

        <span class="k">return</span> <span class="n">warped_imgs</span><span class="p">,</span> <span class="n">warped_grids</span><span class="p">,</span> <span class="n">backward_deformations</span></div></div>


<span class="c1"># Class members that perform non-rigid registrations #</span>
<div class="viewcode-block" id="SimpleElastixWarper"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixWarper">[docs]</a><span class="k">class</span> <span class="nc">SimpleElastixWarper</span><span class="p">(</span><span class="n">NonRigidRegistrarXY</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Uses SimpleElastix to register images</span>

<span class="sd">    May optionally using corresponding points</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SimpleElastixWarper.__init__"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixWarper.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ammi_weight</span><span class="o">=</span><span class="mf">0.33</span><span class="p">,</span>
                 <span class="n">bending_penalty_weight</span><span class="o">=</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">kp_weight</span><span class="o">=</span><span class="mf">0.33</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ammi_weight : float</span>
<span class="sd">            Weight given to the AdvancedMattesMutualInformation metric.</span>

<span class="sd">        bending_penalty_weight : float</span>
<span class="sd">            Weight given to the TransformBendingEnergyPenalty metric.</span>

<span class="sd">        kp_weight : float</span>
<span class="sd">            Weight given to the CorrespondingPointsEuclideanDistanceMetric</span>
<span class="sd">            metric. Only used if moving_xy and fixed_xy are provided as</span>
<span class="sd">            arguments to the `register()` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ammi_weight</span> <span class="o">=</span> <span class="n">ammi_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bending_penalty_weight</span> <span class="o">=</span> <span class="n">bending_penalty_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kp_weight</span> <span class="o">=</span> <span class="n">kp_weight</span></div>


<div class="viewcode-block" id="SimpleElastixWarper.get_default_params"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixWarper.get_default_params">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_default_params</span><span class="p">(</span><span class="n">img_shape</span><span class="p">,</span> <span class="n">grid_spacing_ratio</span><span class="o">=</span><span class="mf">0.025</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get default parameters for registration with sitk.ElastixImageFilter</span>

<span class="sd">        See https://simpleelastix.readthedocs.io/Introduction.html</span>
<span class="sd">        for advice on parameter selection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetDefaultParameterMap</span><span class="p">(</span><span class="s2">&quot;bspline&quot;</span><span class="p">)</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;Metric&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;AdvancedMattesMutualInformation&#39;</span><span class="p">,</span> <span class="s1">&#39;TransformBendingEnergyPenalty&#39;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;MaximumNumberOfIterations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1500&#39;</span><span class="p">]</span>  <span class="c1"># Can try up to 2000</span>
        <span class="n">p</span><span class="p">[</span><span class="s1">&#39;FixedImagePyramid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;FixedRecursiveImagePyramid&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s1">&#39;MovingImagePyramid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;MovingRecursiveImagePyramid&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s1">&#39;Interpolator&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;BSplineInterpolator&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;ImageSampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;RandomCoordinate&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;MetricSamplingStrategy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;None&quot;</span><span class="p">]</span>  <span class="c1"># Use all points</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;UseRandomSampleRegion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;ErodeMask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;NumberOfHistogramBins&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;32&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;NumberOfSpatialSamples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;3000&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;NewSamplesEveryIteration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;SampleRegionSize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="n">img_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">3</span><span class="p">,</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">3</span><span class="p">]))]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;Optimizer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AdaptiveStochasticGradientDescent&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;ASGDParameterEstimationMethod&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;DisplacementDistribution&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;HowToCombineTransforms&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Compose&quot;</span><span class="p">]</span>
        <span class="n">grid_spacing_x</span> <span class="o">=</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">grid_spacing_ratio</span>
        <span class="n">grid_spacing_y</span> <span class="o">=</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">grid_spacing_ratio</span>
        <span class="n">grid_spacing</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">grid_spacing_x</span><span class="p">,</span> <span class="n">grid_spacing_y</span><span class="p">])))</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;FinalGridSpacingInPhysicalUnits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">grid_spacing</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;WriteResultImage&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;false&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">p</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">elastix_invert_transform</span><span class="p">(</span><span class="n">registed_elastix_obj</span><span class="p">,</span> <span class="n">sitk_fixed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Invert transformation as described in elastix manual.</span>

<span class="sd">        See section 6.1.6: DisplacementMagnitudePenalty: inverting transformations</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        registed_elastix_obj: sitk.ElastixImageFilter</span>
<span class="sd">            sitk.ElastixImageFilter object that has completed</span>
<span class="sd">            image registration.</span>

<span class="sd">        sitk_fixed : SimpleITK.Image</span>
<span class="sd">            SimpleITK.Image created from the fixed image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inverted_deformationField : ndarray</span>
<span class="sd">            (N,M,2) numpy array of pixel displacements in the</span>
<span class="sd">            x and y directions.</span>

<span class="sd">        NOTE</span>
<span class="sd">        ----</span>
<span class="sd">        sitk.IterativeInverseDisplacementField seems to do a better job,</span>
<span class="sd">        and is what is used in warp_tools.get_inverse_field. However, this</span>
<span class="sd">        method is maintained in case one would like to use it.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">inverse_transformationFilter</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">TransformixImageFilter</span><span class="p">()</span>
        <span class="n">transf_parameter_map</span> <span class="o">=</span> <span class="n">registed_elastix_obj</span><span class="o">.</span><span class="n">GetTransformParameterMap</span><span class="p">()</span>
        <span class="n">transf_parameter_map</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;Metric&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;DisplacementMagnitudePenalty&quot;</span><span class="p">]</span>
        <span class="n">transf_parameter_map</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;HowToCombineTransforms&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Compose&quot;</span><span class="p">]</span>
        <span class="n">inverse_transformationFilter</span><span class="o">.</span><span class="n">SetMovingImage</span><span class="p">(</span><span class="n">sitk_fixed</span><span class="p">)</span>
        <span class="n">inverse_transformationFilter</span><span class="o">.</span><span class="n">SetTransformParameterMap</span><span class="p">(</span><span class="n">transf_parameter_map</span><span class="p">)</span>
        <span class="n">inverse_transformationFilter</span><span class="o">.</span><span class="n">ComputeDeformationFieldOn</span><span class="p">()</span>
        <span class="n">inverse_transformationFilter</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>
        <span class="n">inverted_deformationField</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">inverse_transformationFilter</span><span class="o">.</span><span class="n">GetDeformationField</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">inverted_deformationField</span>

    <span class="k">def</span> <span class="nf">write_elastix_kp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kp</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Temporarily write fixed_xy and moving_xy to file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kp: ndarray</span>
<span class="sd">            (N, 2) numpy array of points (xy).</span>

<span class="sd">        fname: str</span>
<span class="sd">            Name of file in which to save the points.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">argfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">argfile</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;index</span><span class="se">\n</span><span class="si">{</span><span class="n">npts</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
            <span class="n">xy</span> <span class="o">=</span> <span class="n">kp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">argfile</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run_elastix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="n">moving_xy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_xy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Run SimpleElastix to register images.</span>

<span class="sd">        Can using corresponding points to aid in registration by providing</span>
<span class="sd">        moving_xy and fixed_xy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moving_img : ndarray</span>
<span class="sd">            Image to warp to align with `fixed_img`.</span>

<span class="sd">        fixed_img : ndarray</span>
<span class="sd">            Image `moving_img` is warped to align with.</span>

<span class="sd">        moving_xy : ndarray, optional</span>
<span class="sd">            (N, 2) array containing points in the moving image that correspond</span>
<span class="sd">            to those in the fixed image.</span>

<span class="sd">        fixed_xy : ndarray, optional</span>
<span class="sd">            (N, 2) array containing points in the fixed image that correspond</span>
<span class="sd">            to those in the moving image.</span>

<span class="sd">        mask : ndarray, optional</span>
<span class="sd">            2D array with shape (N,M) where non-zero pixel values are</span>
<span class="sd">            foreground, and 0 is background, which is ignnored during</span>
<span class="sd">            registration. If None, then all non-zero pixels in images</span>
<span class="sd">            will be used to create the mask.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">elastix_image_filter_obj</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">ElastixImageFilter</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">moving_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fixed_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">rand_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
            <span class="n">fixed_kp_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                                          <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">rand_id</span><span class="si">}</span><span class="s2">_fixedPointSet.pts&quot;</span><span class="p">)</span>
            <span class="n">moving_kp_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                                           <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">rand_id</span><span class="si">}</span><span class="s2">_.movingPointSet.pts&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">write_elastix_kp</span><span class="p">(</span><span class="n">fixed_xy</span><span class="p">,</span> <span class="n">fixed_kp_fname</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_elastix_kp</span><span class="p">(</span><span class="n">moving_xy</span><span class="p">,</span> <span class="n">moving_kp_fname</span><span class="p">)</span>

            <span class="n">kp_dist_met</span> <span class="o">=</span> <span class="s2">&quot;CorrespondingPointsEuclideanDistanceMetric&quot;</span>
            <span class="n">current_metrics</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;Metric&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params_provided</span> <span class="ow">or</span> <span class="n">kp_dist_met</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current_metrics</span><span class="p">:</span>
                <span class="n">current_metrics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kp_dist_met</span><span class="p">)</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Metric&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_metrics</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ammi_weight</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">bending_penalty_weight</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">kp_weight</span><span class="p">])</span>

            <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetParameterMap</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetFixedPointSetFileName</span><span class="p">(</span><span class="n">fixed_kp_fname</span><span class="p">)</span>
            <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetMovingPointSetFileName</span><span class="p">(</span><span class="n">moving_kp_fname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ammi_weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bending_penalty_weight</span><span class="p">])</span>

        <span class="c1"># Set metric weights #</span>
        <span class="n">weights</span> <span class="o">/=</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n_metrics</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;Metric&quot;</span><span class="p">])</span>
        <span class="n">n_res</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;NumberOfResolutions&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_metrics</span><span class="p">):</span>
            <span class="n">params</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;Metric</span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s1">Weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">r</span><span class="p">])]</span><span class="o">*</span><span class="n">n_res</span>

        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetParameterMap</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Perform registration #</span>
        <span class="n">sitk_moving</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">moving_img</span><span class="p">)</span>
        <span class="n">sitk_fixed</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">fixed_img</span><span class="p">)</span>
        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetMovingImage</span><span class="p">(</span><span class="n">sitk_moving</span><span class="p">)</span>
        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetFixedImage</span><span class="p">(</span><span class="n">sitk_fixed</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sitk_mask</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">Cast</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)),</span>
                                  <span class="n">sitk</span><span class="o">.</span><span class="n">sitkUInt8</span><span class="p">)</span>

            <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetFixedMask</span><span class="p">(</span><span class="n">sitk_mask</span><span class="p">)</span>

        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>

        <span class="c1"># Get deformation field #</span>
        <span class="n">transformixImageFilter</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">TransformixImageFilter</span><span class="p">()</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">SetTransformParameterMap</span><span class="p">(</span><span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">GetTransformParameterMap</span><span class="p">())</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">ComputeDeformationFieldOn</span><span class="p">()</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>
        <span class="n">deformationField</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">GetDeformationField</span><span class="p">())</span>

        <span class="c1"># Warp image #</span>
        <span class="n">resultImage</span> <span class="o">=</span> <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">GetResultImage</span><span class="p">()</span>
        <span class="n">resultImage</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">resultImage</span><span class="p">)</span>

        <span class="c1"># Get deformation grid #</span>
        <span class="n">grid_spacing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;FinalGridSpacingInPhysicalUnits&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">grid_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_image</span><span class="p">(</span><span class="n">grid_spacing</span><span class="o">=</span><span class="n">grid_spacing</span><span class="p">)</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">SetMovingImage</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">grid_img</span><span class="p">))</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>
        <span class="n">warped_grid</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">GetResultImage</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">moving_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fixed_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fixed_kp_fname</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fixed_kp_fname</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">moving_kp_fname</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">moving_kp_fname</span><span class="p">)</span>

        <span class="n">tform_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;TransformParameters.&quot;</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.txt&quot;</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tform_files</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">tform_files</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">resultImage</span><span class="p">,</span> <span class="n">warped_grid</span><span class="p">,</span> <span class="n">deformationField</span><span class="p">,</span> <span class="n">elastix_image_filter_obj</span><span class="p">,</span> <span class="n">transformixImageFilter</span>

<div class="viewcode-block" id="SimpleElastixWarper.calc"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixWarper.calc">[docs]</a>    <span class="k">def</span> <span class="nf">calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">moving_xy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_xy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform non-rigid registration using SimpleElastix.</span>

<span class="sd">        Can include corresponding points to help in registration by providing</span>
<span class="sd">        `moving_xy` and `fixed_xy`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">moving_img</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">fixed_img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>\
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Images have differernt shapes&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params_provided</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_default_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">warped_img</span><span class="p">,</span> \
            <span class="n">warped_grid</span><span class="p">,</span> \
            <span class="n">backward_deformation</span><span class="p">,</span> \
            <span class="n">backward_elastix_image_filter_obj</span><span class="p">,</span> \
            <span class="n">backward_transformixImageFilter</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">run_elastix</span><span class="p">(</span><span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span>
                             <span class="n">moving_xy</span><span class="o">=</span><span class="n">moving_xy</span><span class="p">,</span> <span class="n">fixed_xy</span><span class="o">=</span><span class="n">fixed_xy</span><span class="p">,</span>
                             <span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1"># Record other params #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_spacing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;FinalGridSpacingInPhysicalUnits&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elastix_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Can&#39;t pickle SimpleITK.ParameterMap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">backward_elastix_image_filter_obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">dxdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">backward_deformation</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">backward_deformation</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">dxdy</span></div></div>


<div class="viewcode-block" id="OpticalFlowWarper"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.OpticalFlowWarper">[docs]</a><span class="k">class</span> <span class="nc">OpticalFlowWarper</span><span class="p">(</span><span class="n">NonRigidRegistrar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Use dense optical flow to register images.</span>

<span class="sd">    Dense optical flow fields may not be diffeomorphic, and so</span>
<span class="sd">    this class provides options to smooth displacement fields.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="OpticalFlowWarper.__init__"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.OpticalFlowWarper.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optical_flow_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_grid_pts</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">sigma_ratio</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
                 <span class="n">paint_size</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">fold_penalty</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
                 <span class="n">smoothing_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : dictionary</span>
<span class="sd">            Keyword: value dictionary of parameters to be used in reigstration.</span>
<span class="sd">            Will get used in the calc() method.</span>

<span class="sd">        optical_flow_obj : object</span>
<span class="sd">            Object that will perform dense optical flow.</span>

<span class="sd">        n_grid_pts : int</span>
<span class="sd">            Number of gridpoints used to detect folds. Also the number</span>
<span class="sd">            of gridpoints to use when regularizing he mesh when</span>
<span class="sd">            `method` = &quot;regularize&quot;.</span>

<span class="sd">        paint_size : int</span>
<span class="sd">            Used to determine how much to resize the image to have</span>
<span class="sd">            efficient inpainting. Larger values = longer processing time.</span>
<span class="sd">            Only used if `smoothing_method` = &quot;inpaint&quot;.</span>

<span class="sd">        fold_penalty : float</span>
<span class="sd">            How much to penalize folding/stretching. Larger values will make</span>
<span class="sd">            the deformation field more uniform, which may or may not be</span>
<span class="sd">            desired, as too much can remove all displacements.</span>
<span class="sd">            Only used if `smoothing_method` = &quot;regularize&quot;</span>

<span class="sd">        sigma_ratio : float</span>
<span class="sd">            Determines the amount of Gaussian smoothing, as</span>
<span class="sd">            sigma = max(shape) *sigma_ratio. Larger values do more</span>
<span class="sd">            smoothing. Only used if `smoothing_method` is &quot;gauss&quot;.</span>

<span class="sd">        smoothing : str</span>
<span class="sd">            If &quot;gauss&quot;, then a Gaussian blur will be applied to the</span>
<span class="sd">            deformation fields, using sigma defined by sigma_ratio.</span>

<span class="sd">            If &quot;inpaint&quot;, folded regions will be detected and removed.</span>
<span class="sd">            Folded regions will then be removed using inpainting.</span>

<span class="sd">            If &quot;regularize&quot;, folded regions will be detected and</span>
<span class="sd">            regularized using the method fescribed in</span>
<span class="sd">            &quot;Foldover-free maps in 50 lines of code&quot; Garanzha et al. 2021.</span>

<span class="sd">            If &quot;None&quot; then no smoothing will be applied.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method</span> <span class="o">=</span> <span class="n">smoothing_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_ratio</span> <span class="o">=</span> <span class="n">sigma_ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paint_size</span> <span class="o">=</span> <span class="n">paint_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fold_penalty</span> <span class="o">=</span> <span class="n">fold_penalty</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_grid_pts</span> <span class="o">=</span> <span class="n">n_grid_pts</span>
        <span class="k">if</span> <span class="n">optical_flow_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">optical_flow_obj</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">optflow</span><span class="o">.</span><span class="n">createOptFlow_DeepFlow</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">optical_flow_obj</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optical_flow_obj</span> <span class="o">=</span> <span class="n">optical_flow_obj</span><span class="p">()</span></div>

<div class="viewcode-block" id="OpticalFlowWarper.calc"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.OpticalFlowWarper.calc">[docs]</a>    <span class="k">def</span> <span class="nf">calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;createOptFlow_DenseRLOF&#39;</span><span class="p">,</span> <span class="s1">&#39;createOptFlow_SimpleFlow&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">moving_img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">moving_img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">gray2rgb</span><span class="p">(</span><span class="n">moving_img</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">fixed_img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">fixed_img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">gray2rgb</span><span class="p">(</span><span class="n">fixed_img</span><span class="p">)</span>

        <span class="n">backward_flow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optical_flow_obj</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">fixed_img</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span>
                                                   <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">moving_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))</span>

        <span class="n">backward_flow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">backward_flow</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">backward_flow</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method</span> <span class="o">==</span> <span class="s2">&quot;gauss&quot;</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_ratio</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">backward_flow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">smooth_dx</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">backward_flow</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">smooth_dy</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">backward_flow</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">backward_flow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">smooth_dx</span><span class="p">,</span> <span class="n">smooth_dy</span><span class="p">])</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method</span> <span class="o">==</span> <span class="s2">&quot;inpaint&quot;</span><span class="p">:</span>
            <span class="n">backward_flow</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">remove_folds_in_dxdy</span><span class="p">(</span><span class="n">backward_flow</span><span class="p">,</span>
                                                            <span class="n">n_grid_pts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_grid_pts</span><span class="p">,</span>
                                                            <span class="n">paint_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">paint_size</span><span class="p">,</span>
                                                            <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing_method</span> <span class="o">==</span> <span class="s2">&quot;regularize&quot;</span><span class="p">:</span>
            <span class="n">backward_flow</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">untangle</span><span class="p">(</span><span class="n">backward_flow</span><span class="p">,</span>
                                                <span class="n">n_grid_pts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_grid_pts</span><span class="p">,</span>
                                                <span class="n">penalty</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fold_penalty</span><span class="p">,</span>
                                                <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">optical_flow_obj</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Can&#39;t pickle OpenCV objects</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">backward_flow</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SimpleElastixGroupwiseWarper"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixGroupwiseWarper">[docs]</a><span class="k">class</span> <span class="nc">SimpleElastixGroupwiseWarper</span><span class="p">(</span><span class="n">NonRigidRegistrarGroupwise</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs groupwise non-rigid registration using SimpleElastix.</span>

<span class="sd">    SimpleElastixGroupwiseWarper can register a collection (&gt;= 2) of images,</span>
<span class="sd">    and so is not limited to pairs of images.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    img_list : list</span>
<span class="sd">        List of images, each with shape (N,M) that are to be co-registered.</span>

<span class="sd">    mask : ndarray</span>
<span class="sd">        2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">        and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">        then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">    shape : tuple of int</span>
<span class="sd">        Number of rows and columns in each image.</span>
<span class="sd">        Will have shaape (N,M).</span>

<span class="sd">    warped_image : ndarray</span>
<span class="sd">        Registered copy of `moving_img`.</span>

<span class="sd">    deformation_field_img : ndarray</span>
<span class="sd">        Image showing deformation applied to a regular grid.</span>

<span class="sd">    backward_dx : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the x-dimension.</span>

<span class="sd">    backward_dy : ndarray</span>
<span class="sd">        (N,M) array defining the displacements in the y-dimension.</span>

<span class="sd">    grid_spacing : int</span>
<span class="sd">        Number of pixels between deformation grid points.</span>

<span class="sd">    method : str</span>
<span class="sd">        Name of registration method.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SimpleElastixGroupwiseWarper.__init__"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixGroupwiseWarper.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimpleElastixGroupwiseWarper.get_default_params"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixGroupwiseWarper.get_default_params">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_default_params</span><span class="p">(</span><span class="n">img_shape</span><span class="p">,</span> <span class="n">grid_spacing_ratio</span><span class="o">=</span><span class="mf">0.025</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See https://simpleelastix.readthedocs.io/Introduction.html for advice on parameter selection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetDefaultParameterMap</span><span class="p">(</span><span class="s2">&quot;groupwise&quot;</span><span class="p">)</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;Metric&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;AdvancedMattesMutualInformation&#39;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;MaximumNumberOfIterations&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1500&#39;</span><span class="p">]</span>  <span class="c1"># Can try up to 2000</span>
        <span class="n">p</span><span class="p">[</span><span class="s1">&#39;FixedImagePyramid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;FixedRecursiveImagePyramid&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s1">&#39;MovingImagePyramid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;MovingRecursiveImagePyramid&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;ImageSampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;RandomCoordinate&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;MetricSamplingStrategy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;None&quot;</span><span class="p">]</span>  <span class="c1"># Use all points</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;UseRandomSampleRegion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;ErodeMask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;NumberOfSpatialSamples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;3000&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;NewSamplesEveryIteration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;Optimizer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AdaptiveStochasticGradientDescent&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;ASGDParameterEstimationMethod&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;DisplacementDistribution&quot;</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;HowToCombineTransforms&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Compose&quot;</span><span class="p">]</span>
        <span class="n">grid_spacing_x</span> <span class="o">=</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">grid_spacing_ratio</span>
        <span class="n">grid_spacing_y</span> <span class="o">=</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">grid_spacing_ratio</span>
        <span class="n">grid_spacing</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">grid_spacing_x</span><span class="p">,</span> <span class="n">grid_spacing_y</span><span class="p">])))</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;FinalGridSpacingInPhysicalUnits&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">grid_spacing</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="s2">&quot;WriteResultImage&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;false&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">p</span></div>

<div class="viewcode-block" id="SimpleElastixGroupwiseWarper.calc"><a class="viewcode-back" href="../../non_rigid_registrars.html#valis.non_rigid_registrars.SimpleElastixGroupwiseWarper.calc">[docs]</a>    <span class="k">def</span> <span class="nf">calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img_list</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">SimpleElastixGroupwiseWarper</span><span class="o">.</span><span class="n">get_default_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">img_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">vectorOfImages</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">VectorOfImage</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">img_list</span><span class="p">:</span>
            <span class="n">vectorOfImages</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>

        <span class="n">image</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">JoinSeries</span><span class="p">(</span><span class="n">vectorOfImages</span><span class="p">)</span>
        <span class="n">elastix_image_filter_obj</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">ElastixImageFilter</span><span class="p">()</span>
        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetFixedImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetMovingImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetParameterMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vectorOfMasks</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">VectorOfImage</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img_list</span><span class="p">)):</span>
                <span class="n">vectorOfMasks</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
            <span class="n">mask3d</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">JoinSeries</span><span class="p">(</span><span class="n">vectorOfMasks</span><span class="p">)</span>
            <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">SetFixedMask</span><span class="p">(</span><span class="n">mask3d</span><span class="p">)</span>

        <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>

        <span class="c1"># Get warped images #</span>
        <span class="n">resultImage</span> <span class="o">=</span> <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">GetResultImage</span><span class="p">()</span>
        <span class="n">resultImage</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">resultImage</span><span class="p">)</span>

        <span class="c1"># Get deformation fields #</span>
        <span class="n">transformixImageFilter</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">TransformixImageFilter</span><span class="p">()</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">SetTransformParameterMap</span><span class="p">(</span><span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="n">GetTransformParameterMap</span><span class="p">())</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">SetMovingImage</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">ComputeDeformationFieldOn</span><span class="p">()</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>
        <span class="n">deformationField</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">GetDeformationField</span><span class="p">())[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Get deformation grid #</span>
        <span class="n">grid_spacing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;FinalGridSpacingInPhysicalUnits&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elastix_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Can&#39;t pickle SimpleITK.ParameterMap</span>
        <span class="n">grid_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_image</span><span class="p">(</span><span class="n">grid_spacing</span><span class="o">=</span><span class="n">grid_spacing</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">elastix_image_filter_obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="n">vectorOfGrids</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">VectorOfImage</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">img_list</span><span class="p">)):</span>
            <span class="n">vectorOfGrids</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sitk</span><span class="o">.</span><span class="n">GetImageFromArray</span><span class="p">(</span><span class="n">grid_img</span><span class="p">))</span>
        <span class="n">grid3d</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">JoinSeries</span><span class="p">(</span><span class="n">vectorOfGrids</span><span class="p">)</span>

        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">SetMovingImage</span><span class="p">(</span><span class="n">grid3d</span><span class="p">)</span>
        <span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">Execute</span><span class="p">()</span>
        <span class="n">warped_grid</span> <span class="o">=</span> <span class="n">sitk</span><span class="o">.</span><span class="n">GetArrayFromImage</span><span class="p">(</span><span class="n">transformixImageFilter</span><span class="o">.</span><span class="n">GetResultImage</span><span class="p">())</span>

        <span class="n">tform_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;TransformParameters.&quot;</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.txt&quot;</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tform_files</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">tform_files</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="n">deformationField</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">deformationField</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">...</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
                                      <span class="n">deformationField</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">...</span><span class="p">,</span>  <span class="mi">1</span><span class="p">]]</span>
                                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">deformationField</span><span class="p">))])</span>
        <span class="k">return</span> <span class="n">deformationField</span></div></div>


<span class="k">class</span> <span class="nc">NonRigidTileRegistrar</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tile-wise non-rigid regisration</span>

<span class="sd">    Slices moving and fixed images into tiles and then registers each tile.</span>
<span class="sd">    Probably best for very large images.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    moving_img : pyvips.Image</span>
<span class="sd">        Image with shape (N,M) thata is  warp to align with `fixed_img`.</span>

<span class="sd">    fixed_img : pyvips.Image</span>
<span class="sd">        Image with shape (N,M) that `moving_img` is warped to align with.</span>

<span class="sd">    mask : pyvips.Image</span>
<span class="sd">        2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">        and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">        then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">    shape : tuple</span>
<span class="sd">        Number of rows and columns in each image. Will be (N,M).</span>

<span class="sd">    bk_dxdy_tiles : list</span>
<span class="sd">        List of bk_dxdy for each tile</span>

<span class="sd">    bk_dxdy : pyvips.Image</span>
<span class="sd">        Backwards isplacement field after stitching `bk_dxdy_tiles` together</span>

<span class="sd">    fwd_dxdy_tiles : list</span>
<span class="sd">        List of forward dxdy for each tile</span>

<span class="sd">    fwd_dxdy : pyvips.Image</span>
<span class="sd">        Displacement field after stitching `fwd_dxdy_tiles` together</span>

<span class="sd">    pbar : tqdm</span>
<span class="sd">        Progress bar to track registration time</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tile_wh</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">tile_buffer</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : dictionary</span>
<span class="sd">            Keyword: value dictionary of parameters to be used in reigstration.</span>
<span class="sd">            Will get used when initializing the `non_rigid_registrar_cls`</span>

<span class="sd">            In the case where simple ITK will be used, params should be</span>
<span class="sd">            a SimpleITK.ParameterMap. Note that numeric values needd to be</span>
<span class="sd">            converted to strings.</span>

<span class="sd">        tile_wh : int</span>
<span class="sd">            Width and height of tiles that will be used for registration</span>

<span class="sd">        tile_buffer : int</span>
<span class="sd">            The amount of overlap between each tile.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_wh</span> <span class="o">=</span> <span class="n">tile_wh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_buffer</span> <span class="o">=</span> <span class="n">tile_buffer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warped_image</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy_tiles</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy_tiles</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pbar</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="nf">norm_img</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">normed_img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">normed_img</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">norm_img_stats</span><span class="p">(</span><span class="n">normed_img</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="n">normed_img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">normed_img</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">normed_img</span>

    <span class="k">def</span> <span class="nf">norm_tiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="n">tile_mask</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Try norming using these tile stats</span>
            <span class="k">if</span> <span class="n">tile_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pos_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tile_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">tile_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">fixed_img</span><span class="p">[</span><span class="n">pos_px</span><span class="p">],</span> <span class="n">moving_img</span><span class="p">[</span><span class="n">pos_px</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tile_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">fixed_img</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">moving_img</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>

            <span class="n">target_processing_stats</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">get_channel_stats</span><span class="p">(</span><span class="n">tile_v</span><span class="p">)</span>

            <span class="n">fixed_normed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_img</span><span class="p">(</span><span class="n">fixed_img</span><span class="p">,</span> <span class="n">target_processing_stats</span><span class="p">,</span> <span class="n">tile_mask</span><span class="p">)</span>
            <span class="n">moving_normed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_img</span><span class="p">(</span><span class="n">moving_img</span><span class="p">,</span> <span class="n">target_processing_stats</span><span class="p">,</span> <span class="n">tile_mask</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># Norm using full image&#39;s stats</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fixed_normed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_img</span><span class="p">(</span><span class="n">fixed_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stats</span><span class="p">,</span> <span class="n">tile_mask</span><span class="p">)</span>
                    <span class="n">moving_normed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_img</span><span class="p">(</span><span class="n">moving_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stats</span><span class="p">,</span> <span class="n">tile_mask</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">fixed_normed</span> <span class="o">=</span> <span class="n">fixed_img</span>
                    <span class="n">moving_normed</span> <span class="o">=</span> <span class="n">moving_img</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fixed_normed</span> <span class="o">=</span> <span class="n">fixed_img</span>
                <span class="n">moving_normed</span> <span class="o">=</span> <span class="n">moving_img</span>

        <span class="k">return</span> <span class="n">moving_normed</span><span class="p">,</span> <span class="n">fixed_normed</span>

    <span class="k">def</span> <span class="nf">process_tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process tiles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">processor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processing_cls</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">img</span><span class="p">,</span> <span class="n">src_f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">processed_img</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">process_image</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">processing_kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># processor.process_image doesn&#39;t take kwargs</span>
            <span class="n">processed_img</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">process_image</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">processed_img</span>


    <span class="k">def</span> <span class="nf">reg_tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile_idx</span><span class="p">,</span> <span class="n">lock</span><span class="p">):</span>

        <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
            <span class="c1"># Use lock when accessing images</span>
            <span class="n">tile_bbox_xywh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expanded_bboxes</span><span class="p">[</span><span class="n">tile_idx</span><span class="p">]</span>
            <span class="n">moving_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span><span class="o">.</span><span class="n">extract_area</span><span class="p">(</span><span class="o">*</span><span class="n">tile_bbox_xywh</span><span class="p">)</span>
            <span class="n">fixed_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span><span class="o">.</span><span class="n">extract_area</span><span class="p">(</span><span class="o">*</span><span class="n">tile_bbox_xywh</span><span class="p">)</span>

            <span class="n">np_fixed</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">fixed_tile</span><span class="p">)</span>
            <span class="n">np_moving</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">moving_tile</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tile_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">extract_area</span><span class="p">(</span><span class="o">*</span><span class="n">tile_bbox_xywh</span><span class="p">)</span>
                <span class="n">np_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">tile_mask</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">np_mask</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">moving_tile</span><span class="o">.</span><span class="n">interpretation</span> <span class="o">==</span> <span class="s2">&quot;srgb&quot;</span><span class="p">:</span>
                <span class="c1"># Limit registration to be inside image</span>
                <span class="c1"># Warped areas outside image have the same pixel values, usually 0</span>
                <span class="n">edge_mask</span> <span class="o">=</span> <span class="mi">255</span><span class="o">*</span><span class="p">((</span><span class="n">np_moving</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np_moving</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np_fixed</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np_fixed</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">np_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">np_mask</span> <span class="o">=</span> <span class="mi">255</span><span class="o">*</span><span class="p">((</span><span class="n">edge_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">np_mask</span> <span class="o">=</span> <span class="n">edge_mask</span>


            <span class="c1"># Check if either of the tiles are empty</span>
            <span class="n">is_empty</span> <span class="o">=</span> <span class="n">fixed_tile</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="n">fixed_tile</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="ow">or</span> <span class="n">moving_tile</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="n">moving_tile</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">np_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">is_empty</span> <span class="o">=</span> <span class="n">is_empty</span> <span class="ow">or</span> <span class="n">np_mask</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">is_empty</span><span class="p">:</span>
                <span class="c1"># Nothing to register</span>
                <span class="n">empty_dxdy</span> <span class="o">=</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">black</span><span class="p">(</span><span class="n">moving_tile</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">moving_tile</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy_tiles</span><span class="p">[</span><span class="n">tile_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">empty_dxdy</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy_tiles</span><span class="p">[</span><span class="n">tile_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">empty_dxdy</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

                <span class="k">return</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">processing_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Process tiles #</span>
                <span class="n">fixed_processed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_tile</span><span class="p">(</span><span class="n">np_fixed</span><span class="p">)</span>
                <span class="n">moving_processed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_tile</span><span class="p">(</span><span class="n">np_moving</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">np_fixed</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">fixed_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">skcolor</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">np_fixed</span><span class="p">))</span>
                    <span class="n">fixed_processed</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">fixed_g</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fixed_processed</span> <span class="o">=</span> <span class="n">np_fixed</span>

                <span class="k">if</span> <span class="n">np_moving</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">moving_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">skcolor</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">np_moving</span><span class="p">))</span>
                    <span class="n">moving_processed</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">moving_g</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">moving_processed</span> <span class="o">=</span> <span class="n">np_moving</span>

            <span class="n">moving_normed</span><span class="p">,</span> <span class="n">fixed_normed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_tiles</span><span class="p">(</span><span class="n">moving_processed</span><span class="p">,</span> <span class="n">fixed_processed</span><span class="p">,</span> <span class="n">np_mask</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">np_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">moving_normed</span><span class="p">[</span><span class="n">np_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">fixed_normed</span><span class="p">[</span><span class="n">np_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Register tiles #</span>
            <span class="n">tile_non_rigid_reg_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar_cls</span><span class="p">()</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">tile_non_rigid_reg_obj</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">moving_normed</span><span class="p">,</span> <span class="n">fixed_normed</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">np_mask</span><span class="p">)</span>
            <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">remove_invasive_displacements</span><span class="p">(</span><span class="n">bk_dxdy</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">src_shape_rc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">moving_normed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">vips_tile_bk_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">bk_dxdy</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

            <span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_inverse_field</span><span class="p">(</span><span class="n">bk_dxdy</span><span class="p">)</span>
            <span class="n">vips_tile_fwd_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">fwd_dxdy</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">np_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">temp_tile_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">np_mask</span><span class="p">)</span>
                <span class="n">vips_tile_bk_dxdy</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp_tile_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ifthenelse</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vips_tile_bk_dxdy</span><span class="p">)</span>
                <span class="n">vips_tile_fwd_dxdy</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp_tile_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ifthenelse</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vips_tile_fwd_dxdy</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy_tiles</span><span class="p">[</span><span class="n">tile_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">vips_tile_bk_dxdy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy_tiles</span><span class="p">[</span><span class="n">tile_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">vips_tile_fwd_dxdy</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cacluate displacement fields</span>
<span class="sd">        Each tile is registered and then stitched together</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;======== Registering tiles</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">lock</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="n">n_cpu</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">parallel_backend</span><span class="p">(</span><span class="s2">&quot;threading&quot;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_cpu</span><span class="p">):</span>
            <span class="n">Parallel</span><span class="p">()(</span><span class="n">delayed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_tile</span><span class="p">)(</span><span class="n">i</span><span class="p">,</span> <span class="n">lock</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span><span class="p">))</span>

        <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">stitch_tiles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy_tiles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expanded_bboxes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_buffer</span><span class="p">)</span>
        <span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">stitch_tiles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy_tiles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expanded_bboxes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_buffer</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ifthenelse</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bk_dxdy</span><span class="p">)</span>
            <span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ifthenelse</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fwd_dxdy</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bk_dxdy</span><span class="p">,</span> <span class="n">fwd_dxdy</span>

    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_img</span><span class="p">,</span> <span class="n">fixed_img</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">non_rigid_registrar_cls</span><span class="o">=</span><span class="n">OpticalFlowWarper</span><span class="p">,</span>
                 <span class="n">processing_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">processing_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_stats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register images, warping moving_img to align with fixed_img</span>

<span class="sd">        Uses backwards transforms to register images (i.e. aligning</span>
<span class="sd">        fixed to moving), so the inverse transform needs to be used</span>
<span class="sd">        to warp points from moving_img. This is automatically done in</span>
<span class="sd">        warp_tools.warp_xy</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moving_img : ndarray, pyvips.Image</span>
<span class="sd">            Image to warp to align with `fixed_img`.</span>

<span class="sd">        fixed_img : ndarray, pyvips.Image</span>
<span class="sd">            Image `moving_img` is warped to align with.</span>

<span class="sd">        mask : ndarray, pyvips.Image</span>
<span class="sd">            2D array with shape (N,M) where non-zero pixel values are foreground,</span>
<span class="sd">            and 0 is background, which is ignnored during registration. If None,</span>
<span class="sd">            then all non-zero pixels in images will be used to create the mask.</span>

<span class="sd">        non_rigid_registrar_cls : NonRigidRegistrar, optional</span>
<span class="sd">            Uninstantiated NonRigidRegistrar class that will be used</span>
<span class="sd">            to calculate the deformation fields between images.</span>

<span class="sd">        processing_cls : preprocessing.ImageProcesser, optional</span>
<span class="sd">            preprocessing.ImageProcesser used to process the images</span>

<span class="sd">        processing_kwargs : dict</span>
<span class="sd">            Dictionary of keyward arguments to be passed to `processing_cls`</span>

<span class="sd">        target_stats : ndarray</span>
<span class="sd">            Target stats used to normalize each tile after being processed.</span>

<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to NonRigidRegistrar.calc</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        warped_img : pyvips.Image</span>
<span class="sd">            Moving image registered to align with fixed image.</span>

<span class="sd">        fwd_dxdy :</span>
<span class="sd">            (2, N, M)  pyvips.Image with pixel displacements in</span>
<span class="sd">            the x and y directions. Found by registering `moving_img`</span>
<span class="sd">            to `fixed_img`. Used for point warping</span>

<span class="sd">        bk_dxdy : pyvips.Image</span>
<span class="sd">            (2, N, M)  pyvips.Image with pixel displacements in</span>
<span class="sd">            the x and y directions. Found by registering `fixed_img` to</span>
<span class="sd">            `moving_img`. Used for image warping</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_array</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">moving_img</span><span class="p">,</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_array</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_array</span><span class="p">:</span>
            <span class="n">shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">moving_img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">moving_img</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">moving_img</span><span class="o">.</span><span class="n">width</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape_rc</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar_cls</span> <span class="o">=</span> <span class="n">non_rigid_registrar_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processing_cls</span> <span class="o">=</span> <span class="n">processing_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_stats</span> <span class="o">=</span> <span class="n">target_stats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processing_kwargs</span> <span class="o">=</span> <span class="n">processing_kwargs</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_array</span><span class="p">:</span>
            <span class="n">moving_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">moving_img</span><span class="p">)</span>
            <span class="n">fixed_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">fixed_img</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">moving_img</span> <span class="o">=</span> <span class="n">moving_img</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_img</span> <span class="o">=</span> <span class="n">fixed_img</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>

        <span class="n">temp_tile_bboxes</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_grid_bboxes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_wh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_wh</span><span class="p">,</span> <span class="n">inclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expanded_bboxes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">expand_bbox</span><span class="p">(</span><span class="n">bbox_xywh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_buffer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox_xywh</span> <span class="ow">in</span> <span class="n">temp_tile_bboxes</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp_tile_bboxes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy_tiles</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy_tiles</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">temp_tile_bboxes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">temp_tile_bboxes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>

        <span class="n">bk_dxdy</span><span class="p">,</span> <span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="p">()</span>

        <span class="n">warped_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">moving_img</span><span class="p">,</span> <span class="n">bk_dxdy</span><span class="o">=</span><span class="n">bk_dxdy</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_array</span><span class="p">:</span>
            <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">bk_dxdy</span><span class="p">)</span>
            <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="p">[</span><span class="n">bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>

            <span class="n">warped_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">warped_img</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">bk_dxdy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="n">fwd_dxdy</span>

        <span class="k">return</span> <span class="n">warped_img</span><span class="p">,</span> <span class="n">fwd_dxdy</span><span class="p">,</span> <span class="n">bk_dxdy</span>


</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Chandler Gatenbee.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>