

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>valis.registration &mdash; valis &#34;1.0.0rc11&#34;
 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: black" >
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/valis_logo_black_no_bg.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../registration.html">Registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../slide_io.html">Slide I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../preprocessing.html">Image pre-processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../feature_detectors.html">Feature detectors and descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../feature_matcher.html">Feature matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../affine_optimizer.html">Affine optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../non_rigid_registrars.html">Non-rigid registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../serial_rigid.html">Serial rigid registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../serial_non_rigid.html">Serial non-rigid registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../viz.html">Visualization</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">valis</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>valis.registration</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for valis.registration</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Classes and functions to register a collection of images</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">transform</span><span class="p">,</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">filters</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="nn">tqdm</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">colour</span>
<span class="kn">import</span> <span class="nn">pyvips</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">feature_matcher</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">serial_rigid</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">feature_detectors</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">non_rigid_registrars</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">valtils</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">preprocessing</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">slide_tools</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">slide_io</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">viz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">warp_tools</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">serial_non_rigid</span>

<span class="n">pyvips</span><span class="o">.</span><span class="n">cache_set_max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Destination directories #</span>
<span class="n">CONVERTED_IMG_DIR</span> <span class="o">=</span> <span class="s2">&quot;images&quot;</span>
<span class="n">PROCESSED_IMG_DIR</span> <span class="o">=</span> <span class="s2">&quot;processed&quot;</span>
<span class="n">RIGID_REG_IMG_DIR</span> <span class="o">=</span> <span class="s2">&quot;rigid_registration&quot;</span>
<span class="n">NON_RIGID_REG_IMG_DIR</span> <span class="o">=</span> <span class="s2">&quot;non_rigid_registration&quot;</span>
<span class="n">DEFORMATION_FIELD_IMG_DIR</span> <span class="o">=</span> <span class="s2">&quot;deformation_fields&quot;</span>
<span class="n">OVERLAP_IMG_DIR</span> <span class="o">=</span> <span class="s2">&quot;overlaps&quot;</span>
<span class="n">REG_RESULTS_DATA_DIR</span> <span class="o">=</span> <span class="s2">&quot;data&quot;</span>
<span class="n">MICRO_REG_DIR</span> <span class="o">=</span> <span class="s2">&quot;micro_registration&quot;</span>
<span class="n">DISPLACEMENT_DIRS</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">REG_RESULTS_DATA_DIR</span><span class="p">,</span> <span class="s2">&quot;displacements&quot;</span><span class="p">)</span>
<span class="n">MASK_DIR</span> <span class="o">=</span> <span class="s2">&quot;masks&quot;</span>

<span class="c1"># Default image processing #</span>
<span class="n">DEFAULT_BRIGHTFIELD_CLASS</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">ColorfulStandardizer</span>
<span class="n">DEFAULT_BRIGHTFIELD_PROCESSING_ARGS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">DEFAULT_COLOR_STD_C</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
<span class="n">DEFAULT_FLOURESCENCE_CLASS</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">ChannelGetter</span>
<span class="n">DEFAULT_FLOURESCENCE_PROCESSING_ARGS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;channel&quot;</span><span class="p">:</span> <span class="s2">&quot;dapi&quot;</span><span class="p">,</span> <span class="s2">&quot;adaptive_eq&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
<span class="n">DEFAULT_NORM_METHOD</span> <span class="o">=</span> <span class="s2">&quot;img_stats&quot;</span>

<span class="c1"># Default rigid registration parameters #</span>
<span class="n">DEFAULT_FD</span> <span class="o">=</span> <span class="n">feature_detectors</span><span class="o">.</span><span class="n">VggFD</span>
<span class="n">DEFAULT_TRANSFORM_CLASS</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">SimilarityTransform</span>
<span class="n">DEFAULT_MATCH_FILTER</span> <span class="o">=</span> <span class="n">feature_matcher</span><span class="o">.</span><span class="n">RANSAC_NAME</span>
<span class="n">DEFAULT_SIMILARITY_METRIC</span> <span class="o">=</span> <span class="s2">&quot;n_matches&quot;</span>
<span class="n">DEFAULT_AFFINE_OPTIMIZER_CLASS</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">DEFAULT_MAX_PROCESSED_IMG_SIZE</span> <span class="o">=</span> <span class="mi">850</span>
<span class="n">DEFAULT_MAX_IMG_DIM</span> <span class="o">=</span> <span class="mi">850</span>
<span class="n">DEFAULT_THUMBNAIL_SIZE</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">DEFAULT_MAX_NON_RIGID_REG_SIZE</span> <span class="o">=</span> <span class="mi">3000</span>

<span class="c1"># Tiled non-rigid registration arguments</span>
<span class="n">TILER_THRESH_GB</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">DEFAULT_NR_TILE_WH</span> <span class="o">=</span> <span class="mi">512</span>

<span class="c1"># Rigid registration kwarg keys #</span>
<span class="n">AFFINE_OPTIMIZER_KEY</span> <span class="o">=</span> <span class="s2">&quot;affine_optimizer&quot;</span>
<span class="n">TRANSFORMER_KEY</span> <span class="o">=</span> <span class="s2">&quot;transformer&quot;</span>
<span class="n">SIM_METRIC_KEY</span> <span class="o">=</span> <span class="s2">&quot;similarity_metric&quot;</span>
<span class="n">FD_KEY</span> <span class="o">=</span> <span class="s2">&quot;feature_detector&quot;</span>
<span class="n">MATCHER_KEY</span> <span class="o">=</span> <span class="s2">&quot;matcher&quot;</span>
<span class="n">NAME_KEY</span> <span class="o">=</span> <span class="s2">&quot;name&quot;</span>
<span class="n">IMAGES_ORDERD_KEY</span> <span class="o">=</span> <span class="s2">&quot;imgs_ordered&quot;</span>
<span class="n">REF_IMG_KEY</span> <span class="o">=</span> <span class="s2">&quot;reference_img_f&quot;</span>
<span class="n">QT_EMMITER_KEY</span> <span class="o">=</span> <span class="s2">&quot;qt_emitter&quot;</span>
<span class="n">TFORM_SRC_SHAPE_KEY</span> <span class="o">=</span> <span class="s2">&quot;transformation_src_shape_rc&quot;</span>
<span class="n">TFORM_DST_SHAPE_KEY</span> <span class="o">=</span> <span class="s2">&quot;transformation_dst_shape_rc&quot;</span>
<span class="n">TFORM_MAT_KEY</span> <span class="o">=</span> <span class="s2">&quot;M&quot;</span>

<span class="c1"># Rigid registration kwarg keys #</span>
<span class="n">NON_RIGID_REG_CLASS_KEY</span> <span class="o">=</span> <span class="s2">&quot;non_rigid_reg_class&quot;</span>
<span class="n">NON_RIGID_REG_PARAMS_KEY</span> <span class="o">=</span> <span class="s2">&quot;non_rigid_reg_params&quot;</span>
<span class="n">NON_RIGID_USE_XY_KEY</span> <span class="o">=</span> <span class="s2">&quot;moving_to_fixed_xy&quot;</span>
<span class="n">NON_RIGID_COMPOSE_KEY</span> <span class="o">=</span> <span class="s2">&quot;compose_transforms&quot;</span>

<span class="c1"># Default non-rigid registration parameters #</span>
<span class="n">DEFAULT_NON_RIGID_CLASS</span> <span class="o">=</span> <span class="n">non_rigid_registrars</span><span class="o">.</span><span class="n">OpticalFlowWarper</span>
<span class="n">DEFAULT_NON_RIGID_KWARGS</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># Cropping options</span>
<span class="n">CROP_OVERLAP</span> <span class="o">=</span> <span class="s2">&quot;overlap&quot;</span>
<span class="n">CROP_REF</span> <span class="o">=</span> <span class="s2">&quot;reference&quot;</span>
<span class="n">CROP_NONE</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>


<div class="viewcode-block" id="init_jvm"><a class="viewcode-back" href="../../registration.html#valis.registration.init_jvm">[docs]</a><span class="k">def</span> <span class="nf">init_jvm</span><span class="p">(</span><span class="n">jar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mem_gb</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Initialize JVM for BioFormats</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">slide_io</span><span class="o">.</span><span class="n">init_jvm</span><span class="p">(</span><span class="n">jar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mem_gb</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></div>


<div class="viewcode-block" id="kill_jvm"><a class="viewcode-back" href="../../registration.html#valis.registration.kill_jvm">[docs]</a><span class="k">def</span> <span class="nf">kill_jvm</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Kill JVM for BioFormats</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">slide_io</span><span class="o">.</span><span class="n">kill_jvm</span><span class="p">()</span></div>


<div class="viewcode-block" id="load_registrar"><a class="viewcode-back" href="../../registration.html#valis.registration.load_registrar">[docs]</a><span class="k">def</span> <span class="nf">load_registrar</span><span class="p">(</span><span class="n">src_f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Load a Valis object</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    src_f : string</span>
<span class="sd">        Path to pickled Valis object</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    registrar : Valis</span>

<span class="sd">        Valis object used for registration</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">registrar</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">src_f</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">))</span>

    <span class="n">data_dir</span> <span class="o">=</span> <span class="n">registrar</span><span class="o">.</span><span class="n">data_dir</span>
    <span class="n">read_data_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">src_f</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># If registrar has moved, will need to update paths to results</span>
    <span class="c1"># and displacement fields</span>
    <span class="k">if</span> <span class="n">data_dir</span> <span class="o">!=</span> <span class="n">read_data_dir</span><span class="p">:</span>
        <span class="n">new_dst_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">read_data_dir</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">registrar</span><span class="o">.</span><span class="n">dst_dir</span> <span class="o">=</span> <span class="n">new_dst_dir</span>
        <span class="n">registrar</span><span class="o">.</span><span class="n">set_dst_paths</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="n">registrar</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">update_results_img_paths</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">registrar</span></div>


<div class="viewcode-block" id="Slide"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide">[docs]</a><span class="k">class</span> <span class="nc">Slide</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Stores registration info and warps slides/points</span>

<span class="sd">    `Slide` is a class that stores registration parameters</span>
<span class="sd">    and other metadata about a slide. Once registration has been</span>
<span class="sd">    completed, `Slide` is also able warp the slide and/or points</span>
<span class="sd">    using the same registration parameters. Warped slides can be saved</span>
<span class="sd">    as ome.tiff images with valid ome-xml.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    src_f : str</span>
<span class="sd">        Path to slide.</span>

<span class="sd">    image: ndarray</span>
<span class="sd">        Image to registered. Taken from a level in the image pyramid.</span>
<span class="sd">        However, image may be resized to fit within the `max_image_dim_px`</span>
<span class="sd">        argument specified when creating a `Valis` object.</span>

<span class="sd">    val_obj : Valis</span>
<span class="sd">        The &quot;parent&quot; object that registers all of the slide.</span>

<span class="sd">    reader : SlideReader</span>
<span class="sd">        Object that can read slides and collect metadata.</span>

<span class="sd">    original_xml : str</span>
<span class="sd">        Xml string created by bio-formats</span>

<span class="sd">    img_type : str</span>
<span class="sd">        Whether the image is &quot;brightfield&quot; or &quot;fluorescence&quot;</span>

<span class="sd">    is_rgb : bool</span>
<span class="sd">        Whether or not the slide is RGB.</span>

<span class="sd">    slide_shape_rc : tuple of int</span>
<span class="sd">        Dimensions of the largest resolution in the slide, in the form</span>
<span class="sd">        of (row, col).</span>

<span class="sd">    series : int</span>
<span class="sd">        Slide series to be read</span>

<span class="sd">    slide_dimensions_wh : ndarray</span>
<span class="sd">        Dimensions of all images in the pyramid (width, height).</span>

<span class="sd">    resolution : float</span>
<span class="sd">        Physical size of each pixel.</span>

<span class="sd">    units : str</span>
<span class="sd">        Physical unit of each pixel.</span>

<span class="sd">    name : str</span>
<span class="sd">        Name of the image. Usually `img_f` but with the extension removed.</span>

<span class="sd">    processed_img : ndarray</span>
<span class="sd">        Image used to perform registration</span>

<span class="sd">    rigid_reg_mask : ndarray</span>
<span class="sd">        Mask of convex hulls covering tissue in unregistered image.</span>
<span class="sd">        Could be used to mask `processed_img` before rigid registration</span>

<span class="sd">    non_rigid_reg_mask : ndarray</span>
<span class="sd">        Created by combining rigidly warped `rigid_reg_mask` in all</span>
<span class="sd">        other slides.</span>

<span class="sd">    stack_idx : int</span>
<span class="sd">        Position of image in sorted Z-stack</span>

<span class="sd">    processed_img_f : str</span>
<span class="sd">        Path to thumbnail of the processed `image`.</span>

<span class="sd">    rigid_reg_img_f : str</span>
<span class="sd">        Path to thumbnail of rigidly aligned `image`.</span>

<span class="sd">    non_rigid_reg_img_f : str</span>
<span class="sd">        Path to thumbnail of non-rigidly aligned `image`.</span>

<span class="sd">    processed_img_shape_rc : tuple of int</span>
<span class="sd">        Shape (row, col) of the processed image used to find the</span>
<span class="sd">        transformation parameters. Maximum dimension will be less or</span>
<span class="sd">        equal to the `max_processed_image_dim_px` specified when</span>
<span class="sd">        creating a `Valis` object. As such, this may be smaller than</span>
<span class="sd">        the image&#39;s shape.</span>

<span class="sd">    aligned_slide_shape_rc : tuple of int</span>
<span class="sd">        Shape (row, col) of aligned slide, based on the dimensions in the 0th</span>
<span class="sd">        level of they pyramid. In</span>

<span class="sd">    reg_img_shape_rc : tuple of int</span>
<span class="sd">        Shape (row, col) of the registered image</span>

<span class="sd">    M : ndarray</span>
<span class="sd">        Rigid transformation matrix that aligns `image` to the previous</span>
<span class="sd">        image in the stack. Found using the processed copy of `image`.</span>

<span class="sd">    bk_dxdy : ndarray</span>
<span class="sd">        (2, N, M) numpy array of pixel displacements in</span>
<span class="sd">        the x and y directions. dx = bk_dxdy[0], and dy=bk_dxdy[1]. Used</span>
<span class="sd">        to warp images. Found using the rigidly aligned version of the</span>
<span class="sd">        processed image.</span>

<span class="sd">    fwd_dxdy : ndarray</span>
<span class="sd">        Inverse of `bk_dxdy`. Used to warp points.</span>

<span class="sd">    _bk_dxdy_f : str</span>
<span class="sd">        Path to file containing bk_dxdy, if saved</span>

<span class="sd">    _fwd_dxdy_f : str</span>
<span class="sd">        Path to file containing fwd_dxdy, if saved</span>

<span class="sd">    _bk_dxdy_np : ndarray</span>
<span class="sd">        `bk_dxdy` as a numpy array. Only not None if `bk_dxdy` becomes</span>
<span class="sd">        associated with a file</span>

<span class="sd">    _fwd_dxdy_np : ndarray</span>
<span class="sd">        `fwd_dxdy` as a numpy array. Only not None if `fwd_dxdy` becomes</span>
<span class="sd">        associated with a file</span>

<span class="sd">    stored_dxdy : bool</span>
<span class="sd">        Whether or not the non-rigid displacements are saved in a file</span>
<span class="sd">        Should only occur if image is very large.</span>

<span class="sd">    fixed_slide : Slide</span>
<span class="sd">        Slide object to which this one was aligned.</span>

<span class="sd">    xy_matched_to_prev : ndarray</span>
<span class="sd">        Coordinates (x, y) of features in `image` that had matches in the</span>
<span class="sd">        previous image. Will have shape (N, 2)</span>

<span class="sd">    xy_in_prev : ndarray</span>
<span class="sd">        Coordinates (x, y) of features in the previous that had matches</span>
<span class="sd">        to those in `image`. Will have shape (N, 2)</span>

<span class="sd">    xy_matched_to_prev_in_bbox : ndarray</span>
<span class="sd">        Subset of `xy_matched_to_prev` that were within `overlap_mask_bbox_xywh`.</span>
<span class="sd">        Will either have shape (N, 2) or (M, 2), with M &lt; N.</span>

<span class="sd">    xy_in_prev_in_bbox : ndarray</span>
<span class="sd">        Subset of `xy_in_prev` that were within `overlap_mask_bbox_xywh`.</span>
<span class="sd">        Will either have shape (N, 2) or (M, 2), with M &lt; N.</span>

<span class="sd">    crop : str</span>
<span class="sd">        Crop method</span>

<span class="sd">    bg_px_pos_rc : tuple</span>
<span class="sd">        Position of pixel that has the background color</span>

<span class="sd">    bg_color : list, optional</span>
<span class="sd">        Color of background pixels</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Slide.__init__"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_f</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">val_obj</span><span class="p">,</span> <span class="n">reader</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_f : str</span>
<span class="sd">            Path to slide.</span>

<span class="sd">        image: ndarray</span>
<span class="sd">            Image to registered. Taken from a level in the image pyramid.</span>
<span class="sd">            However, image may be resized to fit within the `max_image_dim_px`</span>
<span class="sd">            argument specified when creating a `Valis` object.</span>

<span class="sd">        val_obj : Valis</span>
<span class="sd">            The &quot;parent&quot; object that registers all of the slide.</span>

<span class="sd">        reader : SlideReader</span>
<span class="sd">            Object that can read slides and collect metadata.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">src_f</span> <span class="o">=</span> <span class="n">src_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span> <span class="o">=</span> <span class="n">val_obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reader</span> <span class="o">=</span> <span class="n">reader</span>

        <span class="c1"># Metadata #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_rgb</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">is_rgb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">img_type</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">guess_image_type</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slide_shape_rc</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">slide_dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">series</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">series</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slide_dimensions_wh</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">slide_dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">pixel_physical_size_xyu</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">pixel_physical_size_xyu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_xml</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">original_xml</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">src_f</span><span class="p">)</span>

        <span class="c1"># To be filled in during registration #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_reg_mask</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># Created by combining rigid masks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack_idx</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_img_shape_rc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_img_shape_rc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stored_dxdy</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bk_dxdy_f</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fwd_dxdy_f</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bk_dxdy_np</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fwd_dxdy_np</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_img_f</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_img_f</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_reg_img_f</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_slide</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy_matched_to_prev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy_in_prev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy_matched_to_prev_in_bbox</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy_in_prev_in_bbox</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">crop</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bg_px_pos_rc</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bg_color</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Slide.slide2image"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.slide2image">[docs]</a>    <span class="k">def</span> <span class="nf">slide2image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xywh</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert slide to image</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        level : int</span>
<span class="sd">            Pyramid level</span>

<span class="sd">        series : int, optional</span>
<span class="sd">            Series number. Defaults to 0</span>

<span class="sd">        xywh : tuple of int, optional</span>
<span class="sd">            The region to be sliced from the slide. If None,</span>
<span class="sd">            then the entire slide will be converted. Otherwise</span>
<span class="sd">            xywh is the (top left x, top left y, width, height) of</span>
<span class="sd">            the region to be sliced.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        img : ndarray</span>
<span class="sd">            An image of the slide or the region defined by xywh</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">slide2image</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span> <span class="n">xywh</span><span class="o">=</span><span class="n">xywh</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">img</span></div>

<div class="viewcode-block" id="Slide.slide2vips"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.slide2vips">[docs]</a>    <span class="k">def</span> <span class="nf">slide2vips</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xywh</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert slide to pyvips.Image</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        level : int</span>
<span class="sd">            Pyramid level</span>

<span class="sd">        series : int, optional</span>
<span class="sd">            Series number. Defaults to 0</span>

<span class="sd">        xywh : tuple of int, optional</span>
<span class="sd">            The region to be sliced from the slide. If None,</span>
<span class="sd">            then the entire slide will be converted. Otherwise</span>
<span class="sd">            xywh is the (top left x, top left y, width, height) of</span>
<span class="sd">            the region to be sliced.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vips_slide : pyvips.Image</span>
<span class="sd">            An of the slide or the region defined by xywh</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">vips_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">slide2vips</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">,</span> <span class="n">xywh</span><span class="o">=</span><span class="n">xywh</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vips_img</span></div>

    <span class="k">def</span> <span class="nf">get_aligned_to_ref_slide_crop_xywh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_img_shape_rc</span><span class="p">,</span> <span class="n">ref_M</span><span class="p">,</span> <span class="n">scaled_ref_img_shape_rc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get bounding box used to crop slide to fit in reference image</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ref_img_shape_rc : tuple of int</span>
<span class="sd">            shape of reference image used to find registration parameters, i.e. processed image)</span>

<span class="sd">        ref_M : ndarray</span>
<span class="sd">            Transformation matrix for the reference image</span>

<span class="sd">        scaled_ref_img_shape_rc : tuple of int, optional</span>
<span class="sd">            shape of scaled image with shape `img_shape_rc`, i.e. slide corresponding</span>
<span class="sd">            to the image used to find the registration parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        crop_xywh : tuple of int</span>
<span class="sd">            Bounding box of crop area (XYWH)</span>

<span class="sd">        mask : ndarray</span>
<span class="sd">            Mask covering reference image</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mask</span> <span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">get_crop_mask</span><span class="p">(</span><span class="n">CROP_REF</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scaled_ref_img_shape_rc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">scaled_ref_img_shape_rc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">ref_img_shape_rc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scaled_ref_img_shape_rc</span> <span class="o">=</span> <span class="n">ref_img_shape_rc</span>
            <span class="n">sxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">reg_txy</span> <span class="o">=</span> <span class="o">-</span><span class="n">ref_M</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">slide_xywh</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">reg_txy</span><span class="o">*</span><span class="n">sxy</span><span class="p">,</span> <span class="o">*</span><span class="n">scaled_ref_img_shape_rc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">slide_xywh</span><span class="p">,</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">get_overlap_crop_xywh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">warped_img_shape_rc</span><span class="p">,</span> <span class="n">scaled_warped_img_shape_rc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get bounding box used to crop slide to where all slides overlap</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        warped_img_shape_rc : tuple of int</span>
<span class="sd">            shape of registered image</span>

<span class="sd">        warped_scaled_img_shape_rc : tuple of int, optional</span>
<span class="sd">            shape of scaled registered image (i.e. registered slied)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        crop_xywh : tuple of int</span>
<span class="sd">            Bounding box of crop area (XYWH)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="p">,</span> <span class="n">mask_bbox_xywh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">get_crop_mask</span><span class="p">(</span><span class="n">CROP_OVERLAP</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scaled_warped_img_shape_rc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">scaled_warped_img_shape_rc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">warped_img_shape_rc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">to_slide_transformer</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">sxy</span><span class="p">)</span>
        <span class="n">overlap_bbox</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">bbox2xy</span><span class="p">(</span><span class="n">mask_bbox_xywh</span><span class="p">)</span>
        <span class="n">scaled_overlap_bbox</span> <span class="o">=</span> <span class="n">to_slide_transformer</span><span class="p">(</span><span class="n">overlap_bbox</span><span class="p">)</span>
        <span class="n">scaled_overlap_xywh</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span><span class="n">scaled_overlap_bbox</span><span class="p">)</span>

        <span class="n">scaled_overlap_xywh</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">scaled_overlap_xywh</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="n">scaled_overlap_xywh</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">scaled_overlap_xywh</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">scaled_overlap_xywh</span><span class="p">,</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">get_crop_xywh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crop</span><span class="p">,</span> <span class="n">out_shape_rc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get bounding box used to crop aligned slide</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        out_shape_rc : tuple of int, optional</span>
<span class="sd">            If crop is &quot;reference&quot;, this should be the shape of scaled reference image, such</span>
<span class="sd">            as the unwarped slide that corresponds to the unwarped processed reference image.</span>

<span class="sd">            If crop is &quot;overlap&quot;, this should be the shape of the registered slides.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        crop_xywh : tuple of int</span>
<span class="sd">            Bounding box of crop area (XYWH)</span>

<span class="sd">        mask : ndarray</span>
<span class="sd">            Mask, before crop</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">crop</span> <span class="o">==</span> <span class="n">CROP_REF</span><span class="p">:</span>
            <span class="n">transformation_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">)</span>
            <span class="n">crop_xywh</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_aligned_to_ref_slide_crop_xywh</span><span class="p">(</span><span class="n">ref_img_shape_rc</span><span class="o">=</span><span class="n">transformation_shape_rc</span><span class="p">,</span>
                                                                      <span class="n">ref_M</span><span class="o">=</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                                      <span class="n">scaled_ref_img_shape_rc</span><span class="o">=</span><span class="n">out_shape_rc</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">crop</span> <span class="o">==</span> <span class="n">CROP_OVERLAP</span><span class="p">:</span>
            <span class="n">transformation_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">)</span>
            <span class="n">crop_xywh</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_overlap_crop_xywh</span><span class="p">(</span><span class="n">warped_img_shape_rc</span><span class="o">=</span><span class="n">transformation_shape_rc</span><span class="p">,</span>
                                                         <span class="n">scaled_warped_img_shape_rc</span><span class="o">=</span><span class="n">out_shape_rc</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">crop_xywh</span><span class="p">,</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">get_crop_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get string or logic defining how to crop the image</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">crop</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">crop_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">crop_method</span> <span class="o">=</span> <span class="n">crop</span>

        <span class="n">do_crop</span> <span class="o">=</span> <span class="n">crop_method</span> <span class="ow">in</span> <span class="p">[</span><span class="n">CROP_REF</span><span class="p">,</span> <span class="n">CROP_OVERLAP</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">do_crop</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">crop_method</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">get_bg_color_px_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get position of pixel that has color used for background</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">img_type</span> <span class="o">==</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">IHC_NAME</span><span class="p">:</span>
            <span class="c1"># RGB. Get brightest pixel</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
            <span class="k">with</span> <span class="n">colour</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">suppress_warnings</span><span class="p">(</span><span class="n">colour_usage_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">255</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                    <span class="n">cam</span> <span class="o">=</span> <span class="n">colour</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">/</span><span class="mi">255</span> <span class="o">+</span> <span class="n">eps</span><span class="p">,</span> <span class="s1">&#39;sRGB&#39;</span><span class="p">,</span> <span class="s1">&#39;CAM16UCS&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cam</span> <span class="o">=</span> <span class="n">colour</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">+</span> <span class="n">eps</span><span class="p">,</span> <span class="s1">&#39;sRGB&#39;</span><span class="p">,</span> <span class="s1">&#39;CAM16UCS&#39;</span><span class="p">)</span>

            <span class="n">lum</span> <span class="o">=</span> <span class="n">cam</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">bg_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">lum</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">lum</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># IF. Get darkest pixel</span>
            <span class="n">sum_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">bg_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">sum_img</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">sum_img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bg_px_pos_rc</span> <span class="o">=</span> <span class="n">bg_px</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bg_color</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">bg_px</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">update_results_img_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n_digits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">stack_id</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack_idx</span><span class="p">),</span> <span class="n">n_digits</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">processed_img_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">processed_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_img_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">reg_dst_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stack_id</span><span class="si">}</span><span class="s2">_f</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_reg_img_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">non_rigid_dst_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stack_id</span><span class="si">}</span><span class="s2">_f</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stored_dxdy</span><span class="p">:</span>
            <span class="n">bk_dxdy_f</span><span class="p">,</span> <span class="n">fwd_dxdy_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_displacement_f</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bk_dxdy_f</span> <span class="o">=</span> <span class="n">bk_dxdy_f</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fwd_dxdy_f</span> <span class="o">=</span> <span class="n">fwd_dxdy_f</span>

    <span class="k">def</span> <span class="nf">get_displacement_f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">bk_dxdy_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">displacements_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_bk_dxdy.tiff&quot;</span><span class="p">)</span>
        <span class="n">fwd_dxdy_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">displacements_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_fwd_dxdy.tiff&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bk_dxdy_f</span><span class="p">,</span> <span class="n">fwd_dxdy_f</span>

    <span class="k">def</span> <span class="nf">get_bk_dxdy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stored_dxdy</span><span class="p">:</span>
            <span class="n">bk_dxdy_f</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_displacement_f</span><span class="p">()</span>
            <span class="n">cropped_bk_dxdy</span> <span class="o">=</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">new_from_file</span><span class="p">(</span><span class="n">bk_dxdy_f</span><span class="p">)</span>
            <span class="n">full_bk_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">pad_displacement</span><span class="p">(</span><span class="n">cropped_bk_dxdy</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">_full_displacement_shape_rc</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">_non_rigid_bbox</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">full_bk_dxdy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bk_dxdy_np</span>

    <span class="k">def</span> <span class="nf">set_bk_dxdy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bk_dxdy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Only set if an array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bk_dxdy</span><span class="p">,</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bk_dxdy_np</span> <span class="o">=</span> <span class="n">bk_dxdy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot set bk_dxdy when data is type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">bk_dxdy</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">get_bk_dxdy</span><span class="p">,</span>
                       <span class="n">fset</span><span class="o">=</span><span class="n">set_bk_dxdy</span><span class="p">,</span>
                       <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Get and set backwards displacements&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_fwd_dxdy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stored_dxdy</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">fwd_dxdy_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_displacement_f</span><span class="p">()</span>
            <span class="n">cropped_fwd_dxdy</span> <span class="o">=</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">new_from_file</span><span class="p">(</span><span class="n">fwd_dxdy_f</span><span class="p">)</span>
            <span class="n">full_fwd_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">pad_displacement</span><span class="p">(</span><span class="n">cropped_fwd_dxdy</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">_full_displacement_shape_rc</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">_non_rigid_bbox</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">full_fwd_dxdy</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fwd_dxdy_np</span>

    <span class="k">def</span> <span class="nf">set_fwd_dxdy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fwd_dxdy</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fwd_dxdy</span><span class="p">,</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fwd_dxdy_np</span> <span class="o">=</span> <span class="n">fwd_dxdy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot set fwd_dxdy when data is type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">fwd_dxdy</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">get_fwd_dxdy</span><span class="p">,</span>
                        <span class="n">fset</span><span class="o">=</span><span class="n">set_fwd_dxdy</span><span class="p">,</span>
                        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Get forward displacements&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Slide.warp_img"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.warp_img">[docs]</a>    <span class="k">def</span> <span class="nf">warp_img</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;bicubic&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Warp an image using the registration parameters</span>

<span class="sd">        img : ndarray, optional</span>
<span class="sd">            The image to be warped. If None, then Slide.image</span>
<span class="sd">            will be warped.</span>

<span class="sd">        non_rigid : bool</span>
<span class="sd">            Whether or not to conduct non-rigid warping. If False,</span>
<span class="sd">            then only a rigid transformation will be applied.</span>

<span class="sd">        crop: bool, str</span>
<span class="sd">            How to crop the registered images. If `True`, then the same crop used</span>
<span class="sd">            when initializing the `Valis` object will be used. If `False`, the</span>
<span class="sd">            image will not be cropped. If &quot;overlap&quot;, the warped slide will be</span>
<span class="sd">            cropped to include only areas where all images overlapped.</span>
<span class="sd">            &quot;reference&quot; crops to the area that overlaps with the reference image,</span>
<span class="sd">            defined by `reference_img_f` when initialzing the `Valis object`.</span>

<span class="sd">        interp_method : str</span>
<span class="sd">            Interpolation method used when warping slide. Default is &quot;bicubic&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        warped_img : ndarray</span>
<span class="sd">            Warped copy of `img`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">img</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span>

        <span class="k">if</span> <span class="n">non_rigid</span><span class="p">:</span>
            <span class="n">dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>
            <span class="n">img_shape_rc</span> <span class="o">=</span> <span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img_shape_rc</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">img_shape_rc</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;scaling transformation for image with different shape. &quot;</span>
                   <span class="s2">&quot;However, without knowing all of other image&#39;s shapes, &quot;</span>
                   <span class="s2">&quot;the scaling may not be the same for all images, and so&quot;</span>
                   <span class="s2">&quot;may not overlap.&quot;</span>
                   <span class="p">)</span>
            <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">same_shape</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">img_scale_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img_shape_rc</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">))</span>
            <span class="n">out_shape_rc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">get_aligned_slide_shape</span><span class="p">(</span><span class="n">img_scale_rc</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">same_shape</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">out_shape_rc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_img_shape_rc</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crop</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crop</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">crop_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crop_method</span><span class="p">(</span><span class="n">crop</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">crop_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">crop_method</span> <span class="o">==</span> <span class="n">CROP_REF</span><span class="p">:</span>
                    <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">same_shape</span><span class="p">:</span>
                        <span class="n">scaled_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">)</span><span class="o">*</span><span class="n">img_scale_rc</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">scaled_shape_rc</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">processed_img_shape_rc</span>
                <span class="k">elif</span> <span class="n">crop_method</span> <span class="o">==</span> <span class="n">CROP_OVERLAP</span><span class="p">:</span>
                    <span class="n">scaled_shape_rc</span> <span class="o">=</span> <span class="n">out_shape_rc</span>

                <span class="n">bbox_xywh</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crop_xywh</span><span class="p">(</span><span class="n">crop_method</span><span class="p">,</span> <span class="n">scaled_shape_rc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bbox_xywh</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crop</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">crop</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">bbox_xywh</span> <span class="o">=</span> <span class="n">crop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bbox_xywh</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">bg_color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bg_color</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bg_color</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">warped_img</span> <span class="o">=</span> \
            <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                <span class="n">bk_dxdy</span><span class="o">=</span><span class="n">dxdy</span><span class="p">,</span>
                                <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">out_shape_rc</span><span class="p">,</span>
                                <span class="n">transformation_src_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                <span class="n">transformation_dst_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span>
                                <span class="n">bbox_xywh</span><span class="o">=</span><span class="n">bbox_xywh</span><span class="p">,</span>
                                <span class="n">bg_color</span><span class="o">=</span><span class="n">bg_color</span><span class="p">,</span>
                                <span class="n">interp_method</span><span class="o">=</span><span class="n">interp_method</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">warped_img</span></div>


    <span class="k">def</span> <span class="nf">warp_img_from_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">to_slide_obj</span><span class="p">,</span>
                        <span class="n">dst_slide_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;bicubic&quot;</span><span class="p">,</span> <span class="n">bg_color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Warp an image from this slide onto another unwarped slide</span>

<span class="sd">        Note that if `img` is a labeled image then it is recommended to set `interp_method` to &quot;nearest&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        img : ndarray, pyvips.Image</span>
<span class="sd">            Image to warp. Should be a scaled version of the same one used for registration</span>

<span class="sd">        to_slide_obj : Slide</span>
<span class="sd">            Slide to which the points will be warped. I.e. `xy`</span>
<span class="sd">            will be warped from this Slide to their position in</span>
<span class="sd">            the unwarped slide associated with `to_slide_obj`.</span>

<span class="sd">        dst_slide_level: int, tuple, optional</span>
<span class="sd">            Pyramid level of the slide/image that `img` will be warped on to</span>

<span class="sd">        non_rigid : bool, optional</span>
<span class="sd">            Whether or not to conduct non-rigid warping. If False,</span>
<span class="sd">            then only a rigid transformation will be applied.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dst_slide_level</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">to_slide_src_shape_rc</span> <span class="o">=</span> <span class="n">to_slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="n">dst_slide_level</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">get_aligned_slide_shape</span><span class="p">(</span><span class="n">dst_slide_level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="n">to_slide_src_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dst_slide_level</span><span class="p">)</span>

            <span class="n">dst_scale_rc</span> <span class="o">=</span> <span class="p">(</span><span class="n">to_slide_src_shape_rc</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">to_slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">))</span>
            <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">dst_scale_rc</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">to_slide_obj</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">non_rigid</span><span class="p">:</span>
            <span class="n">from_bk_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy</span>
            <span class="n">to_fwd_dxdy</span> <span class="o">=</span> <span class="n">to_slide_obj</span><span class="o">.</span><span class="n">fwd_dxdy</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">from_bk_dxdy</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">to_fwd_dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">warped_img</span> <span class="o">=</span> \
            <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img_from_to</span><span class="p">(</span><span class="n">img</span><span class="p">,</span>
                                        <span class="n">from_M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                        <span class="n">from_transformation_src_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                        <span class="n">from_transformation_dst_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span>
                                        <span class="n">from_dst_shape_rc</span><span class="o">=</span><span class="n">aligned_slide_shape</span><span class="p">,</span>
                                        <span class="n">from_bk_dxdy</span><span class="o">=</span><span class="n">from_bk_dxdy</span><span class="p">,</span>
                                        <span class="n">to_M</span><span class="o">=</span><span class="n">to_slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                        <span class="n">to_transformation_src_shape_rc</span><span class="o">=</span><span class="n">to_slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                        <span class="n">to_transformation_dst_shape_rc</span><span class="o">=</span><span class="n">to_slide_obj</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span>
                                        <span class="n">to_src_shape_rc</span><span class="o">=</span><span class="n">to_slide_src_shape_rc</span><span class="p">,</span>
                                        <span class="n">to_fwd_dxdy</span><span class="o">=</span><span class="n">to_fwd_dxdy</span><span class="p">,</span>
                                        <span class="n">bg_color</span><span class="o">=</span><span class="n">bg_color</span><span class="p">,</span>
                                        <span class="n">interp_method</span><span class="o">=</span><span class="n">interp_method</span>
                                        <span class="p">)</span>

        <span class="k">return</span> <span class="n">warped_img</span>



<div class="viewcode-block" id="Slide.warp_slide"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.warp_slide">[docs]</a>    <span class="nd">@valtils</span><span class="o">.</span><span class="n">deprecated_args</span><span class="p">(</span><span class="n">crop_to_overlap</span><span class="o">=</span><span class="s2">&quot;crop&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">warp_slide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">src_f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;bicubic&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Warp a slide using registration parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int</span>
<span class="sd">            Pyramid level to be warped</span>

<span class="sd">        non_rigid : bool, optional</span>
<span class="sd">            Whether or not to conduct non-rigid warping. If False,</span>
<span class="sd">            then only a rigid transformation will be applied. Default is True</span>

<span class="sd">        crop: bool, str</span>
<span class="sd">            How to crop the registered images. If `True`, then the same crop used</span>
<span class="sd">            when initializing the `Valis` object will be used. If `False`, the</span>
<span class="sd">            image will not be cropped. If &quot;overlap&quot;, the warped slide will be</span>
<span class="sd">            cropped to include only areas where all images overlapped.</span>
<span class="sd">            &quot;reference&quot; crops to the area that overlaps with the reference image,</span>
<span class="sd">            defined by `reference_img_f` when initialzing the `Valis object`.</span>

<span class="sd">        src_f : str, optional</span>
<span class="sd">           Path of slide to be warped. If None (the default), Slide.src_f</span>
<span class="sd">           will be used. Otherwise, the file to which `src_f` points to should</span>
<span class="sd">           be an alternative copy of the slide, such as one that has undergone</span>
<span class="sd">           processing (e.g. stain segmentation), has a mask applied, etc...</span>

<span class="sd">        interp_method : str</span>
<span class="sd">            Interpolation method used when warping slide. Default is &quot;bicubic&quot;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">src_f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">src_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_f</span>

        <span class="k">if</span> <span class="n">non_rigid</span><span class="p">:</span>
            <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bk_dxdy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">level</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Need slide level to be an integer indicating pyramid level&quot;</span>
                <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">get_aligned_slide_shape</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crop</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crop</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">crop_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crop_method</span><span class="p">(</span><span class="n">crop</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">crop_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">crop_method</span> <span class="o">==</span> <span class="n">CROP_REF</span><span class="p">:</span>
                    <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>
                    <span class="n">scaled_aligned_shape_rc</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="n">level</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">crop_method</span> <span class="o">==</span> <span class="n">CROP_OVERLAP</span><span class="p">:</span>
                    <span class="n">scaled_aligned_shape_rc</span> <span class="o">=</span> <span class="n">aligned_slide_shape</span>

                <span class="n">slide_bbox_xywh</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crop_xywh</span><span class="p">(</span><span class="n">crop</span><span class="o">=</span><span class="n">crop_method</span><span class="p">,</span>
                                                        <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">scaled_aligned_shape_rc</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">crop_method</span> <span class="o">==</span> <span class="n">CROP_REF</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">slide_bbox_xywh</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">==</span><span class="n">scaled_aligned_shape_rc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slide_bbox_xywh</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crop</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">crop</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">slide_bbox_xywh</span> <span class="o">=</span> <span class="n">crop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slide_bbox_xywh</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">src_f</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_f</span><span class="p">:</span>
            <span class="n">bg_color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bg_color</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bg_color</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">warped_slide</span> <span class="o">=</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">warp_slide</span><span class="p">(</span><span class="n">src_f</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                              <span class="n">transformation_src_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                              <span class="n">transformation_dst_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span>
                                              <span class="n">aligned_slide_shape_rc</span><span class="o">=</span><span class="n">aligned_slide_shape</span><span class="p">,</span>
                                              <span class="n">dxdy</span><span class="o">=</span><span class="n">bk_dxdy</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">,</span>
                                              <span class="n">interp_method</span><span class="o">=</span><span class="n">interp_method</span><span class="p">,</span>
                                              <span class="n">bbox_xywh</span><span class="o">=</span><span class="n">slide_bbox_xywh</span><span class="p">,</span>
                                              <span class="n">bg_color</span><span class="o">=</span><span class="n">bg_color</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">warped_slide</span></div>

<div class="viewcode-block" id="Slide.warp_and_save_slide"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.warp_and_save_slide">[docs]</a>    <span class="nd">@valtils</span><span class="o">.</span><span class="n">deprecated_args</span><span class="p">(</span><span class="n">crop_to_overlap</span><span class="o">=</span><span class="s2">&quot;crop&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">warp_and_save_slide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dst_f</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">src_f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">channel_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">perceputally_uniform_channel_colors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;bicubic&quot;</span><span class="p">,</span>
                            <span class="n">tile_wh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;lzw&quot;</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Warp and save a slide</span>

<span class="sd">        Slides will be saved in the ome.tiff format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dst_f : str</span>
<span class="sd">            Path to were the warped slide will be saved.</span>

<span class="sd">        level : int</span>
<span class="sd">            Pyramid level to be warped</span>

<span class="sd">        non_rigid : bool, optional</span>
<span class="sd">            Whether or not to conduct non-rigid warping. If False,</span>
<span class="sd">            then only a rigid transformation will be applied. Default is True</span>

<span class="sd">        crop: bool, str</span>
<span class="sd">            How to crop the registered images. If `True`, then the same crop used</span>
<span class="sd">            when initializing the `Valis` object will be used. If `False`, the</span>
<span class="sd">            image will not be cropped. If &quot;overlap&quot;, the warped slide will be</span>
<span class="sd">            cropped to include only areas where all images overlapped.</span>
<span class="sd">            &quot;reference&quot; crops to the area that overlaps with the reference image,</span>
<span class="sd">            defined by `reference_img_f` when initialzing the `Valis object`.</span>

<span class="sd">        channel_names : list, optional</span>
<span class="sd">            List of channel names. If None, then Slide.reader</span>
<span class="sd">            will attempt to find the channel names associated with `src_f`.</span>

<span class="sd">        src_f : str, optional</span>
<span class="sd">           Path of slide to be warped. If None (the deffault), Slide.src_f</span>
<span class="sd">           will be used. Otherwise, the file to which `src_f` points to should</span>
<span class="sd">           be an alternative copy of the slide, such as one that has undergone</span>
<span class="sd">           processing (e.g. stain segmentation), has a mask applied, etc...</span>

<span class="sd">        interp_method : str</span>
<span class="sd">            Interpolation method used when warping slide. Default is &quot;bicubic&quot;</span>

<span class="sd">        tile_wh : int, optional</span>
<span class="sd">            Tile width and height used to save image</span>

<span class="sd">        compression : str</span>
<span class="sd">            Compression method used to save ome.tiff . Default is lzw, but can also</span>
<span class="sd">            be jpeg or jp2k. See pyips for more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">warped_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp_slide</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="n">non_rigid</span><span class="p">,</span>
                                       <span class="n">crop</span><span class="o">=</span><span class="n">crop</span><span class="p">,</span>
                                       <span class="n">interp_method</span><span class="o">=</span><span class="n">interp_method</span><span class="p">)</span>

        <span class="c1"># Get ome-xml #</span>
        <span class="n">slide_meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">metadata</span>
        <span class="k">if</span> <span class="n">slide_meta</span><span class="o">.</span><span class="n">pixel_physical_size_xyu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">PIXEL_UNIT</span><span class="p">:</span>
            <span class="n">px_phys_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">px_phys_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">scale_physical_size</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">channel_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">src_f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">channel_names</span> <span class="o">=</span> <span class="n">slide_meta</span><span class="o">.</span><span class="n">channel_names</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reader_cls</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">get_slide_reader</span><span class="p">(</span><span class="n">src_f</span><span class="p">)</span>
                <span class="n">reader</span> <span class="o">=</span> <span class="n">reader_cls</span><span class="p">(</span><span class="n">src_f</span><span class="p">)</span>
                <span class="n">channel_names</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">channel_names</span>

        <span class="n">bf_dtype</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">vips2bf_dtype</span><span class="p">(</span><span class="n">warped_slide</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
        <span class="n">out_xyczt</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">get_shape_xyzct</span><span class="p">((</span><span class="n">warped_slide</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">warped_slide</span><span class="o">.</span><span class="n">height</span><span class="p">),</span> <span class="n">warped_slide</span><span class="o">.</span><span class="n">bands</span><span class="p">)</span>
        <span class="n">ome_xml_obj</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">update_xml_for_new_img</span><span class="p">(</span><span class="n">slide_meta</span><span class="o">.</span><span class="n">original_xml</span><span class="p">,</span>
                                                      <span class="n">new_xyzct</span><span class="o">=</span><span class="n">out_xyczt</span><span class="p">,</span>
                                                      <span class="n">bf_dtype</span><span class="o">=</span><span class="n">bf_dtype</span><span class="p">,</span>
                                                      <span class="n">is_rgb</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_rgb</span><span class="p">,</span>
                                                      <span class="n">pixel_physical_size_xyu</span><span class="o">=</span><span class="n">px_phys_size</span><span class="p">,</span>
                                                      <span class="n">channel_names</span><span class="o">=</span><span class="n">channel_names</span><span class="p">,</span>
                                                      <span class="n">perceputally_uniform_channel_colors</span><span class="o">=</span><span class="n">perceputally_uniform_channel_colors</span>
                                                      <span class="p">)</span>

        <span class="n">ome_xml</span> <span class="o">=</span> <span class="n">ome_xml_obj</span><span class="o">.</span><span class="n">to_xml</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tile_wh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tile_wh</span> <span class="o">=</span> <span class="n">slide_meta</span><span class="o">.</span><span class="n">optimal_tile_wh</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">down_sampling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">slide_meta</span><span class="o">.</span><span class="n">slide_dimensions</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">/</span><span class="n">slide_meta</span><span class="o">.</span><span class="n">slide_dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">tile_wh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">tile_wh</span><span class="o">*</span><span class="n">down_sampling</span><span class="p">))</span>
                <span class="n">tile_wh</span> <span class="o">=</span> <span class="n">tile_wh</span> <span class="o">-</span> <span class="p">(</span><span class="n">tile_wh</span> <span class="o">%</span> <span class="mi">16</span><span class="p">)</span>  <span class="c1"># Tile shape must be multiple of 16</span>
                <span class="k">if</span> <span class="n">tile_wh</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>
                    <span class="n">tile_wh</span> <span class="o">=</span> <span class="mi">16</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_xyczt</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tile_wh</span><span class="p">):</span>
                    <span class="n">tile_wh</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">out_xyczt</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">slide_io</span><span class="o">.</span><span class="n">save_ome_tiff</span><span class="p">(</span><span class="n">warped_slide</span><span class="p">,</span> <span class="n">dst_f</span><span class="o">=</span><span class="n">dst_f</span><span class="p">,</span> <span class="n">ome_xml</span><span class="o">=</span><span class="n">ome_xml</span><span class="p">,</span>
                               <span class="n">tile_wh</span><span class="o">=</span><span class="n">tile_wh</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span></div>

<div class="viewcode-block" id="Slide.warp_xy"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.warp_xy">[docs]</a>    <span class="k">def</span> <span class="nf">warp_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">slide_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pt_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Warp points using registration parameters</span>

<span class="sd">        Warps `xy` to their location in the registered slide/image</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xy : ndarray</span>
<span class="sd">            (N, 2) array of points to be warped. Must be x,y coordinates</span>

<span class="sd">        slide_level: int, tuple, optional</span>
<span class="sd">            Pyramid level of the slide. Used to scale transformation matrices.</span>
<span class="sd">            Can also be the shape of the warped image (row, col) into which</span>
<span class="sd">            the points should be warped. Default is 0.</span>

<span class="sd">        pt_level: int, tuple, optional</span>
<span class="sd">            Pyramid level from which the points origingated. For example, if</span>
<span class="sd">            `xy` are from the centroids of cell segmentation performed on the</span>
<span class="sd">            full resolution image, this should be 0. Alternatively, the value can</span>
<span class="sd">            be a tuple of the image&#39;s shape (row, col) from which the points came.</span>
<span class="sd">            For example, if `xy` are  bounding box coordinates from an analysis on</span>
<span class="sd">            a lower resolution image, then pt_level is that lower resolution</span>
<span class="sd">            image&#39;s shape (row, col). Default is 0.</span>

<span class="sd">        non_rigid : bool, optional</span>
<span class="sd">            Whether or not to conduct non-rigid warping. If False,</span>
<span class="sd">            then only a rigid transformation will be applied. Default is True.</span>

<span class="sd">        crop: bool, str</span>
<span class="sd">            Apply crop to warped points by shifting points to the mask&#39;s origin.</span>
<span class="sd">            Note that this can result in negative coordinates, but might be useful</span>
<span class="sd">            if wanting to draw the coordinates on the registered slide, such as</span>
<span class="sd">            annotation coordinates.</span>

<span class="sd">            If `True`, then the same crop used</span>
<span class="sd">            when initializing the `Valis` object will be used. If `False`, the</span>
<span class="sd">            image will not be cropped. If &quot;overlap&quot;, the warped slide will be</span>
<span class="sd">            cropped to include only areas where all images overlapped.</span>
<span class="sd">            &quot;reference&quot; crops to the area that overlaps with the reference image,</span>
<span class="sd">            defined by `reference_img_f` when initialzing the `Valis object`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pt_level</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">pt_dim_rc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="n">pt_level</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pt_dim_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt_level</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">slide_level</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">slide_level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">slide_level</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                    <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">get_aligned_slide_shape</span><span class="p">(</span><span class="n">slide_level</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slide_level</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slide_level</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">non_rigid</span><span class="p">:</span>
            <span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">warped_xy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span>
                                       <span class="n">transformation_src_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                       <span class="n">transformation_dst_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span>
                                       <span class="n">src_shape_rc</span><span class="o">=</span><span class="n">pt_dim_rc</span><span class="p">,</span>
                                       <span class="n">dst_shape_rc</span><span class="o">=</span><span class="n">aligned_slide_shape</span><span class="p">,</span>
                                       <span class="n">fwd_dxdy</span><span class="o">=</span><span class="n">fwd_dxdy</span><span class="p">)</span>

        <span class="n">crop_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crop_method</span><span class="p">(</span><span class="n">crop</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">crop_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">crop_method</span> <span class="o">==</span> <span class="n">CROP_REF</span><span class="p">:</span>
                <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slide_level</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">scaled_aligned_shape_rc</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="n">slide_level</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slide_level</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">scaled_aligned_shape_rc</span> <span class="o">=</span> <span class="n">slide_level</span>
            <span class="k">elif</span> <span class="n">crop_method</span> <span class="o">==</span> <span class="n">CROP_OVERLAP</span><span class="p">:</span>
                <span class="n">scaled_aligned_shape_rc</span> <span class="o">=</span> <span class="n">aligned_slide_shape</span>

            <span class="n">crop_bbox_xywh</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crop_xywh</span><span class="p">(</span><span class="n">crop_method</span><span class="p">,</span> <span class="n">scaled_aligned_shape_rc</span><span class="p">)</span>
            <span class="n">warped_xy</span> <span class="o">-=</span> <span class="n">crop_bbox_xywh</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">warped_xy</span></div>

<div class="viewcode-block" id="Slide.warp_xy_from_to"><a class="viewcode-back" href="../../registration.html#valis.registration.Slide.warp_xy_from_to">[docs]</a>    <span class="k">def</span> <span class="nf">warp_xy_from_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">to_slide_obj</span><span class="p">,</span> <span class="n">src_slide_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">src_pt_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">dst_slide_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Warp points from this slide to another unwarped slide</span>

<span class="sd">        Takes a set of points found in this unwarped slide, and warps them to</span>
<span class="sd">        their position in the unwarped &quot;to&quot; slide.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xy : ndarray</span>
<span class="sd">            (N, 2) array of points to be warped. Must be x,y coordinates</span>

<span class="sd">        to_slide_obj : Slide</span>
<span class="sd">            Slide to which the points will be warped. I.e. `xy`</span>
<span class="sd">            will be warped from this Slide to their position in</span>
<span class="sd">            the unwarped slide associated with `to_slide_obj`.</span>

<span class="sd">        src_pt_level: int, tuple, optional</span>
<span class="sd">            Pyramid level of the slide/image in which `xy` originated.</span>
<span class="sd">            For example, if `xy` are from the centroids of cell segmentation</span>
<span class="sd">            performed on the unwarped full resolution image, this should be 0.</span>
<span class="sd">            Alternatively, the value can be a tuple of the image&#39;s shape (row, col)</span>
<span class="sd">            from which the points came. For example, if `xy` are  bounding</span>
<span class="sd">            box coordinates from an analysis on a lower resolution image,</span>
<span class="sd">            then pt_level is that lower resolution image&#39;s shape (row, col).</span>

<span class="sd">        dst_slide_level: int, tuple, optional</span>
<span class="sd">            Pyramid level of the slide/image in to `xy` will be warped.</span>
<span class="sd">            Similar to `src_pt_level`, if `dst_slide_level` is an int then</span>
<span class="sd">            the points will be warped to that pyramid level. If `dst_slide_level`</span>
<span class="sd">            is the &quot;to&quot; image&#39;s shape (row, col), then the points will be warped</span>
<span class="sd">            to their location in an image with that same shape.</span>

<span class="sd">        non_rigid : bool, optional</span>
<span class="sd">            Whether or not to conduct non-rigid warping. If False,</span>
<span class="sd">            then only a rigid transformation will be applied.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">src_pt_level</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">src_pt_dim_rc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="n">src_pt_level</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">src_pt_dim_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">src_pt_level</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dst_slide_level</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">to_slide_src_shape_rc</span> <span class="o">=</span> <span class="n">to_slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="n">dst_slide_level</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_slide_src_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dst_slide_level</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">src_slide_level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">src_slide_level</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_obj</span><span class="o">.</span><span class="n">get_aligned_slide_shape</span><span class="p">(</span><span class="n">src_slide_level</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">src_slide_level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aligned_slide_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span>

        <span class="k">if</span> <span class="n">non_rigid</span><span class="p">:</span>
            <span class="n">src_fwd_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwd_dxdy</span>
            <span class="n">dst_bk_dxdy</span> <span class="o">=</span> <span class="n">to_slide_obj</span><span class="o">.</span><span class="n">bk_dxdy</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">src_fwd_dxdy</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">dst_bk_dxdy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">xy_in_unwarped_to_img</span> <span class="o">=</span> \
            <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_xy_from_to</span><span class="p">(</span><span class="n">xy</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span>
                                       <span class="n">from_M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                       <span class="n">from_transformation_dst_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span>
                                       <span class="n">from_transformation_src_shape_rc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                       <span class="n">from_dst_shape_rc</span><span class="o">=</span><span class="n">aligned_slide_shape</span><span class="p">,</span>
                                       <span class="n">from_src_shape_rc</span><span class="o">=</span><span class="n">src_pt_dim_rc</span><span class="p">,</span>
                                       <span class="n">from_fwd_dxdy</span><span class="o">=</span><span class="n">src_fwd_dxdy</span><span class="p">,</span>
                                       <span class="n">to_M</span><span class="o">=</span><span class="n">to_slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                       <span class="n">to_transformation_src_shape_rc</span><span class="o">=</span><span class="n">to_slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                       <span class="n">to_transformation_dst_shape_rc</span><span class="o">=</span><span class="n">to_slide_obj</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span>
                                       <span class="n">to_src_shape_rc</span><span class="o">=</span><span class="n">to_slide_src_shape_rc</span><span class="p">,</span>
                                       <span class="n">to_dst_shape_rc</span><span class="o">=</span><span class="n">aligned_slide_shape</span><span class="p">,</span>
                                       <span class="n">to_bk_dxdy</span><span class="o">=</span><span class="n">dst_bk_dxdy</span>
                                       <span class="p">)</span>

        <span class="k">return</span> <span class="n">xy_in_unwarped_to_img</span></div></div>


<div class="viewcode-block" id="Valis"><a class="viewcode-back" href="../../registration.html#valis.registration.Valis">[docs]</a><span class="k">class</span> <span class="nc">Valis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reads, registers, and saves a series of slides/images</span>

<span class="sd">    Implements the registration pipeline described in</span>
<span class="sd">    &quot;VALIS: Virtual Alignment of pathoLogy Image Series&quot; by Gatenbee et al.</span>
<span class="sd">    This pipeline will read images and whole slide images (WSI) using pyvips,</span>
<span class="sd">    bioformats, or openslide, and so should work with a wide variety of formats.</span>
<span class="sd">    VALIS can perform both rigid and non-rigid registration. The registered slides</span>
<span class="sd">    can be saved as ome.tiff slides that can be used in downstream analyses. The</span>
<span class="sd">    ome.tiff format is opensource and widely supported, being readable in several</span>
<span class="sd">    different programming languages (Python, Java, Matlab, etc...) and software,</span>
<span class="sd">    such as QuPath or HALO.</span>

<span class="sd">    The pipeline is fully automated and goes as follows:</span>

<span class="sd">    1. Images/slides are converted to numpy arrays. As WSI are often</span>
<span class="sd">    too large to fit into memory, these images are usually lower resolution</span>
<span class="sd">    images from different pyramid levels.</span>

<span class="sd">    2. Images are processed to single channel images. They are then</span>
<span class="sd">    normalized to make them look as similar as possible.</span>

<span class="sd">    3. Image features are detected and then matched between all pairs of image.</span>

<span class="sd">    4. If the order of images is unknown, they will be optimally ordered</span>
<span class="sd">    based on their feature similarity</span>

<span class="sd">    5. Rigid registration is performed serially, with each image being</span>
<span class="sd">    rigidly aligned to the previous image in the stack.</span>

<span class="sd">    6. Non-rigid registration is then performed either by 1) aliging each image</span>
<span class="sd">    towards the center of the stack, composing the deformation fields</span>
<span class="sd">    along the way, or 2) using groupwise registration that non-rigidly aligns</span>
<span class="sd">    the images to a common frame of reference.</span>

<span class="sd">    7. Error is measured by calculating the distance between registered</span>
<span class="sd">    matched features.</span>

<span class="sd">    The transformations found by VALIS can then be used to warp the full</span>
<span class="sd">    resolution slides. It is also possible to merge non-RGB registered slides</span>
<span class="sd">    to create a highly multiplexed image. These aligned and/or merged slides</span>
<span class="sd">    can then be saved as ome.tiff images using pyvips.</span>

<span class="sd">    In addition to warping images and slides, VALIS can also warp point data,</span>
<span class="sd">    such as cell centoids or ROI coordinates.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Descriptive name of registrar, such as the sample&#39;s name.</span>

<span class="sd">    src_dir: str</span>
<span class="sd">        Path to directory containing the slides that will be registered.</span>

<span class="sd">    dst_dir : str</span>
<span class="sd">        Path to where the results should be saved.</span>

<span class="sd">    original_img_list : list of ndarray</span>
<span class="sd">        List of images converted from the slides in `src_dir`</span>

<span class="sd">    slide_dims_dict_wh :</span>
<span class="sd">        Dictionary of slide dimensions. Only needed if dimensions not</span>
<span class="sd">        available in the slide/image&#39;s metadata.</span>

<span class="sd">    resolution_xyu: tuple</span>
<span class="sd">        Physical size per pixel and the unit.</span>

<span class="sd">    image_type : str</span>
<span class="sd">        Type of image, i.e. &quot;brightfield&quot; or &quot;fluorescence&quot;</span>

<span class="sd">    series : int</span>
<span class="sd">        Slide series to that was read.</span>

<span class="sd">    size : int</span>
<span class="sd">        Number of images to align</span>

<span class="sd">    aligned_img_shape_rc : tuple of int</span>
<span class="sd">        Shape (row, col) of aligned images</span>

<span class="sd">    aligned_slide_shape_rc : tuple of int</span>
<span class="sd">        Shape (row, col) of the aligned slides</span>

<span class="sd">    slide_dict : dict of Slide</span>
<span class="sd">        Dictionary of Slide objects, each of which contains information</span>
<span class="sd">        about a slide, and methods to warp it.</span>

<span class="sd">    brightfield_procsseing_fxn_str: str</span>
<span class="sd">        Name of function used to process brightfield images.</span>

<span class="sd">    if_procsseing_fxn_str : str</span>
<span class="sd">        Name of function used to process fluorescence images.</span>

<span class="sd">    max_image_dim_px : int</span>
<span class="sd">        Maximum width or height of images that will be saved.</span>
<span class="sd">        This limit is mostly to keep memory in check.</span>

<span class="sd">    max_processed_image_dim_px : int</span>
<span class="sd">        Maximum width or height of processed images. An important</span>
<span class="sd">        parameter, as it determines the size of of the image in which</span>
<span class="sd">        features will be detected and displacement fields computed.</span>

<span class="sd">    reference_img_f : str</span>
<span class="sd">        Filename of image that will be treated as the center of the stack.</span>
<span class="sd">        If None, the index of the middle image will be the reference.</span>

<span class="sd">    reference_img_idx : int</span>
<span class="sd">        Index of slide that corresponds to `reference_img_f`, after</span>
<span class="sd">        the `img_obj_list` has been sorted during rigid registration.</span>

<span class="sd">    align_to_reference : bool</span>
<span class="sd">        Whether or not images should be aligne to a reference image</span>
<span class="sd">        specified by `reference_img_f`. Will be set to True if</span>
<span class="sd">        `reference_img_f` is provided.</span>

<span class="sd">    crop: str, optional</span>
<span class="sd">        How to crop the registered images.</span>

<span class="sd">    rigid_registrar : SerialRigidRegistrar</span>
<span class="sd">        SerialRigidRegistrar object that performs the rigid registration.</span>

<span class="sd">    rigid_reg_kwargs : dict</span>
<span class="sd">        Dictionary of keyward arguments passed to</span>
<span class="sd">        `serial_rigid.register_images`.</span>

<span class="sd">    feature_descriptor_str : str</span>
<span class="sd">        Name of feature descriptor.</span>

<span class="sd">    feature_detector_str : str</span>
<span class="sd">        Name of feature detector.</span>

<span class="sd">    transform_str : str</span>
<span class="sd">        Name of rigid transform</span>

<span class="sd">    similarity_metric : str</span>
<span class="sd">        Name of similarity metric used to order slides.</span>

<span class="sd">    match_filter_method : str</span>
<span class="sd">        Name of method used to filter out poor feature matches.</span>

<span class="sd">    non_rigid_registrar : SerialNonRigidRegistrar</span>
<span class="sd">        SerialNonRigidRegistrar object that performs serial</span>
<span class="sd">        non-rigid registration.</span>

<span class="sd">    non_rigid_reg_kwargs : dict</span>
<span class="sd">        Dictionary of keyward arguments passed to</span>
<span class="sd">        `serial_non_rigid.register_images`.</span>

<span class="sd">    non_rigid_registrar_cls : NonRigidRegistrar</span>
<span class="sd">        Uninstantiated NonRigidRegistrar class that will be used</span>
<span class="sd">        by `non_rigid_registrar` to calculate the deformation fields</span>
<span class="sd">        between images.</span>

<span class="sd">    non_rigid_reg_class_str : str</span>
<span class="sd">        Name of the of class `non_rigid_registrar_cls` belongs to.</span>

<span class="sd">    thumbnail_size : int</span>
<span class="sd">        Maximum width or height of thumbnails that show results</span>

<span class="sd">    original_overlap_img : ndarray</span>
<span class="sd">        Image showing how original images overlap before registration.</span>
<span class="sd">        Created by merging coloring the inverted greyscale copies of each</span>
<span class="sd">        image, and then merging those images.</span>

<span class="sd">    rigid_overlap_img : ndarray</span>
<span class="sd">        Image showing how images overlap after rigid registration.</span>

<span class="sd">    non_rigid_overlap_img : ndarray</span>
<span class="sd">        Image showing how images overlap after rigid + non-rigid registration.</span>

<span class="sd">    has_rounds : bool</span>
<span class="sd">        Whether or not the contents of `src_dir` contain subdirectories that</span>
<span class="sd">        have single images spread across multiple files. An example would be</span>
<span class="sd">        .ndpis images.</span>

<span class="sd">    norm_method : str</span>
<span class="sd">        Name of method used to normalize the processed images</span>

<span class="sd">    target_processing_stats : ndarray</span>
<span class="sd">        Array of processed images&#39; stats used to normalize all images</span>

<span class="sd">    summary_df : pd.Dataframe</span>
<span class="sd">        Pandas dataframe containing information about the results, such</span>
<span class="sd">        as the error, shape of aligned slides, time to completion, etc...</span>

<span class="sd">    start_time : float</span>
<span class="sd">        The time at which registation was initiated.</span>

<span class="sd">    end_rigid_time : float</span>
<span class="sd">        The time at which rigid registation was completed.</span>

<span class="sd">    end_non_rigid_time : float</span>
<span class="sd">        The time at which non-rigid registation was completed.</span>

<span class="sd">    qt_emitter : PySide2.QtCore.Signal</span>
<span class="sd">        Used to emit signals that update the GUI&#39;s progress bars</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Basic example using default parameters</span>

<span class="sd">    &gt;&gt;&gt; from valis import registration, data</span>
<span class="sd">    &gt;&gt;&gt; slide_src_dir = data.dcis_src_dir</span>
<span class="sd">    &gt;&gt;&gt; results_dst_dir = &quot;./slide_registration_example&quot;</span>
<span class="sd">    &gt;&gt;&gt; registered_slide_dst_dir = &quot;./slide_registration_example/registered_slides&quot;</span>

<span class="sd">    Perform registration</span>

<span class="sd">    &gt;&gt;&gt; rigid_registrar, non_rigid_registrar, error_df = registrar.register()</span>

<span class="sd">    View results in &quot;./slide_registration_example&quot;.</span>
<span class="sd">    If they look good, warp and save the slides as ome.tiff</span>

<span class="sd">    &gt;&gt;&gt; registrar.warp_and_save_slides(registered_slide_dst_dir)</span>

<span class="sd">    This example shows how to register CyCIF images and then merge</span>
<span class="sd">    to create a high dimensional ome.tiff slide</span>

<span class="sd">    &gt;&gt;&gt; registrar = registration.Valis(slide_src_dir, results_dst_dir)</span>
<span class="sd">    &gt;&gt;&gt; rigid_registrar, non_rigid_registrar, error_df = registrar.register()</span>

<span class="sd">    Create function to get marker names from each slides&#39; filename</span>

<span class="sd">    &gt;&gt;&gt; def cnames_from_filename(src_f):</span>
<span class="sd">    ...     f = valtils.get_name(src_f)</span>
<span class="sd">    ...     return [&quot;DAPI&quot;] + f.split(&quot; &quot;)[1:4]</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; channel_name_dict = {f:cnames_from_filename(f) for f in  registrar.original_img_list}</span>
<span class="sd">    &gt;&gt;&gt; merged_img, channel_names, ome_xml = registrar.warp_and_merge_slides(merged_slide_dst_f, channel_name_dict=channel_name_dict)</span>

<span class="sd">    View ome.tiff, located at merged_slide_dst_f</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Valis.__init__"><a class="viewcode-back" href="../../registration.html#valis.registration.Valis.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_dir</span><span class="p">,</span> <span class="n">dst_dir</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">img_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">feature_detector_cls</span><span class="o">=</span><span class="n">DEFAULT_FD</span><span class="p">,</span>
                 <span class="n">transformer_cls</span><span class="o">=</span><span class="n">DEFAULT_TRANSFORM_CLASS</span><span class="p">,</span>
                 <span class="n">affine_optimizer_cls</span><span class="o">=</span><span class="n">DEFAULT_AFFINE_OPTIMIZER_CLASS</span><span class="p">,</span>
                 <span class="n">similarity_metric</span><span class="o">=</span><span class="n">DEFAULT_SIMILARITY_METRIC</span><span class="p">,</span>
                 <span class="n">match_filter_method</span><span class="o">=</span><span class="n">DEFAULT_MATCH_FILTER</span><span class="p">,</span>
                 <span class="n">imgs_ordered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">non_rigid_registrar_cls</span><span class="o">=</span><span class="n">DEFAULT_NON_RIGID_CLASS</span><span class="p">,</span>
                 <span class="n">non_rigid_reg_params</span><span class="o">=</span><span class="n">DEFAULT_NON_RIGID_KWARGS</span><span class="p">,</span>
                 <span class="n">compose_non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">img_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">reference_img_f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">align_to_reference</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">do_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">crop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">create_masks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">resolution_xyu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">slide_dims_dict_wh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">max_image_dim_px</span><span class="o">=</span><span class="n">DEFAULT_MAX_IMG_DIM</span><span class="p">,</span>
                 <span class="n">max_processed_image_dim_px</span><span class="o">=</span><span class="n">DEFAULT_MAX_PROCESSED_IMG_SIZE</span><span class="p">,</span>
                 <span class="n">max_non_rigid_registartion_dim_px</span><span class="o">=</span><span class="n">DEFAULT_MAX_PROCESSED_IMG_SIZE</span><span class="p">,</span>
                 <span class="n">thumbnail_size</span><span class="o">=</span><span class="n">DEFAULT_THUMBNAIL_SIZE</span><span class="p">,</span>
                 <span class="n">norm_method</span><span class="o">=</span><span class="n">DEFAULT_NORM_METHOD</span><span class="p">,</span> <span class="n">qt_emitter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        src_dir: str</span>
<span class="sd">            Path to directory containing the slides that will be registered.</span>

<span class="sd">        dst_dir : str</span>
<span class="sd">            Path to where the results should be saved.</span>

<span class="sd">        name : str, optional</span>
<span class="sd">            Descriptive name of registrar, such as the sample&#39;s name</span>

<span class="sd">        series : int, optional</span>
<span class="sd">            Slide series to that was read. If None, series will be set to 0.</span>

<span class="sd">        img_type : str, optional</span>
<span class="sd">            The type of image, either &quot;brightfield&quot;, &quot;fluorescence&quot;,</span>
<span class="sd">            or &quot;multi&quot;. If None, VALIS will guess `img_type`</span>
<span class="sd">            of each image, based on the number of channels and datatype.</span>
<span class="sd">            Will assume that RGB = &quot;brightfield&quot;,</span>
<span class="sd">            otherwise `img_type` will be set to &quot;fluorescence&quot;.</span>

<span class="sd">        feature_detector_cls : FeatureDD, optional</span>
<span class="sd">            Uninstantiated FeatureDD object that detects and computes</span>
<span class="sd">            image features. Default is VggFD. The</span>
<span class="sd">            available feature_detectors are found in the `feature_detectors`</span>
<span class="sd">            module. If a desired feature detector is not available,</span>
<span class="sd">            one can be created by subclassing `feature_detectors.FeatureDD`.</span>

<span class="sd">        transformer_cls : scikit-image Transform class, optional</span>
<span class="sd">            Uninstantiated scikit-image transformer used to find</span>
<span class="sd">            transformation matrix that will warp each image to the target</span>
<span class="sd">            image. Default is SimilarityTransform</span>

<span class="sd">        affine_optimizer_cls : AffineOptimzer class, optional</span>
<span class="sd">            Uninstantiated AffineOptimzer that will minimize a</span>
<span class="sd">            cost function to find the optimal affine transformations.</span>
<span class="sd">            If a desired affine optimization is not available,</span>
<span class="sd">            one can be created by subclassing `affine_optimizer.AffineOptimizer`.</span>

<span class="sd">        similarity_metric : str, optional</span>
<span class="sd">            Metric used to calculate similarity between images, which is in</span>
<span class="sd">            turn used to build the distance matrix used to sort the images.</span>
<span class="sd">            Can be &quot;n_matches&quot;, or a string to used as</span>
<span class="sd">            distance in spatial.distance.cdist. &quot;n_matches&quot;</span>
<span class="sd">            is the number of matching features between image pairs.</span>

<span class="sd">        match_filter_method: str, optional</span>
<span class="sd">            &quot;GMS&quot; will use filter_matches_gms() to remove poor matches.</span>
<span class="sd">            This uses the Grid-based Motion Statistics (GMS) or RANSAC.</span>

<span class="sd">        imgs_ordered : bool, optional</span>
<span class="sd">            Boolean defining whether or not the order of images in img_dir</span>
<span class="sd">            are already in the correct order. If True, then each filename should</span>
<span class="sd">            begin with the number that indicates its position in the z-stack. If</span>
<span class="sd">            False, then the images will be sorted by ordering a feature distance</span>
<span class="sd">            matix. Default is False.</span>

<span class="sd">        reference_img_f : str, optional</span>
<span class="sd">            Filename of image that will be treated as the center of the stack.</span>
<span class="sd">            If None, the index of the middle image will be the reference.</span>

<span class="sd">        align_to_reference : bool, optional</span>
<span class="sd">            If `False`, images will be non-rigidly aligned serially towards the</span>
<span class="sd">            reference image. If `True`, images will be non-rigidly aligned</span>
<span class="sd">            directly to the reference image. If `reference_img_f` is None,</span>
<span class="sd">            then the reference image will be the one in the middle of the stack.</span>

<span class="sd">        non_rigid_registrar_cls : NonRigidRegistrar, optional</span>
<span class="sd">            Uninstantiated NonRigidRegistrar class that will be used to</span>
<span class="sd">            calculate the deformation fields between images. See</span>
<span class="sd">            the `non_rigid_registrars` module for a desciption of available</span>
<span class="sd">            methods. If a desired non-rigid registration method is not available,</span>
<span class="sd">            one can be implemented by subclassing.NonRigidRegistrar.</span>
<span class="sd">            If None, then only rigid registration will be performed</span>

<span class="sd">        non_rigid_reg_params: dictionary, optional</span>
<span class="sd">            Dictionary containing key, value pairs to be used to initialize</span>
<span class="sd">            `non_rigid_registrar_cls`.</span>
<span class="sd">            In the case where simple ITK is used by the, params should be</span>
<span class="sd">            a SimpleITK.ParameterMap. Note that numeric values nedd to be</span>
<span class="sd">            converted to strings. See the NonRigidRegistrar classes in</span>
<span class="sd">            `non_rigid_registrars` for the available non-rigid registration</span>
<span class="sd">            methods and arguments.</span>

<span class="sd">        compose_non_rigid : bool, optional</span>
<span class="sd">            Whether or not to compose non-rigid transformations. If `True`,</span>
<span class="sd">            then an image is non-rigidly warped before aligning to the</span>
<span class="sd">            adjacent non-rigidly aligned image. This allows the transformations</span>
<span class="sd">            to accumulate, which may bring distant features together but could</span>
<span class="sd">            also  result  in un-wanted deformations, particularly around the edges.</span>
<span class="sd">            If `False`, the image not warped before being aaligned to the adjacent</span>
<span class="sd">            non-rigidly aligned image. This can reduce unwanted deformations, but</span>
<span class="sd">            may not bring distant features together.</span>

<span class="sd">        do_rigid: bool, dictionary, optional</span>
<span class="sd">            Whether or not to perform rigid registration. If `False`, rigid</span>
<span class="sd">            registration will be skipped.</span>

<span class="sd">            If `do_rigid` is a dictionary, it should contain inverse transformation</span>
<span class="sd">            matrices to rigidly align images to the specificed by `reference_img_f`.</span>
<span class="sd">            M will be estimated for images that are not in the dictionary.</span>
<span class="sd">            Each key is the filename of the image associated with the transformation matrix,</span>
<span class="sd">            and value is a dictionary containing the following values:</span>
<span class="sd">                `M` : (required) a 3x3 inverse transformation matrix as a numpy array.</span>
<span class="sd">                      Found by determining how to align fixed to moving.</span>
<span class="sd">                      If `M` was found by determining how to align moving to fixed,</span>
<span class="sd">                      then `M` will need to be inverted first.</span>
<span class="sd">                `transformation_src_shape_rc` : (optional) shape (row, col) of image used to find the rigid transformation.</span>
<span class="sd">                      If not provided, then it is assumed to be the shape of the level 0 slide</span>
<span class="sd">                `transformation_dst_shape_rc` : (optional) shape of registered image.</span>
<span class="sd">                      If not provided, this is assumed to be the shape of the level 0 reference slide.</span>

<span class="sd">        crop: str, optional</span>
<span class="sd">            How to crop the registered images. &quot;overlap&quot; will crop to include</span>
<span class="sd">            only areas where all images overlapped. &quot;reference&quot; crops to the</span>
<span class="sd">            area that overlaps with a reference image, defined by</span>
<span class="sd">            `reference_img_f`. This option can be used even if `reference_img_f`</span>
<span class="sd">            is `None` because the reference image will be set as the one at the center</span>
<span class="sd">            of the stack.</span>

<span class="sd">            If both `crop` and `reference_img_f` are `None`, `crop`</span>
<span class="sd">            will be set to &quot;overlap&quot;. If `crop` is None, but `reference_img_f`</span>
<span class="sd">            is defined, then `crop` will be set to &quot;reference&quot;.</span>

<span class="sd">        create_masks : bool, optional</span>
<span class="sd">            Whether or not to create and apply masks for registration.</span>
<span class="sd">            Can help focus alignment on the tissue, but can sometimes</span>
<span class="sd">            mask too much if there is a lot of variation in the image.</span>

<span class="sd">        resolution_xyu: tuple, optional</span>
<span class="sd">            Physical size per pixel and the unit. If None (the default), these</span>
<span class="sd">            values will be determined for each slide using the slides&#39; metadata.</span>
<span class="sd">            If provided, this physical pixel sizes will be used for all of the slides.</span>
<span class="sd">            This option is available in case one cannot easily access to the original</span>
<span class="sd">            slides, but does have the information on pixel&#39;s physical units.</span>

<span class="sd">        slide_dims_dict_wh : dict, optional</span>
<span class="sd">            Key= slide/image file name,</span>
<span class="sd">            value= dimensions = [(width, height), (width, height), ...] for each level.</span>
<span class="sd">            If None (the default), the slide dimensions will be pulled from the</span>
<span class="sd">            slides&#39; metadata. If provided, those values will be overwritten. This</span>
<span class="sd">            option is available in case one cannot easily access to the original</span>
<span class="sd">            slides, but does have the information on the slide dimensions.</span>

<span class="sd">        max_image_dim_px : int, optional</span>
<span class="sd">            Maximum width or height of images that will be saved.</span>
<span class="sd">            This limit is mostly to keep memory in check.</span>

<span class="sd">        max_processed_image_dim_px : int, optional</span>
<span class="sd">            Maximum width or height of processed images. An important</span>
<span class="sd">            parameter, as it determines the size of of the image in which</span>
<span class="sd">            features will be detected and displacement fields computed.</span>

<span class="sd">        max_non_rigid_registartion_dim_px : int, optional</span>
<span class="sd">             Maximum width or height of images used for non-rigid registration.</span>
<span class="sd">             Larger values may yeild more accurate results, at the expense of</span>
<span class="sd">             speed and memory. There is also a practical limit, as the specified</span>
<span class="sd">             size may be too large to fit in memory.</span>

<span class="sd">        mask_dict : dictionary</span>
<span class="sd">            Dictionary where key = overlap type (all, overlap, or reference), and</span>
<span class="sd">            value = (mask, mask_bbox_xywh)</span>

<span class="sd">        thumbnail_size : int, optional</span>
<span class="sd">            Maximum width or height of thumbnails that show results</span>

<span class="sd">        norm_method : str</span>
<span class="sd">            Name of method used to normalize the processed images. Options</span>
<span class="sd">            are &quot;histo_match&quot; for histogram matching, &quot;img_stats&quot; for normalizing by</span>
<span class="sd">            image statistics. See preprocessing.match_histograms</span>
<span class="sd">            and preprocessing.norm_khan for details.</span>

<span class="sd">        _non_rigid_bbox : list</span>
<span class="sd">            Bounding box of area in which non-rigid registration was conducted</span>

<span class="sd">        _full_displacement_shape_rc : tuple</span>
<span class="sd">            Shape of full displacement field. Would be larger than `_non_rigid_bbox`</span>
<span class="sd">            if non-rigid registration only performed in a masked region</span>

<span class="sd">        qt_emitter : PySide2.QtCore.Signal, optional</span>
<span class="sd">            Used to emit signals that update the GUI&#39;s progress bars</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">src_dir</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>

        <span class="c1"># Set paths #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">src_dir</span> <span class="o">=</span> <span class="n">src_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">img_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span> <span class="o">=</span> <span class="n">img_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_imgs_in_dir</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_dst_paths</span><span class="p">()</span>

        <span class="c1"># Some information may already be provided #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slide_dims_dict_wh</span> <span class="o">=</span> <span class="n">slide_dims_dict_wh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution_xyu</span> <span class="o">=</span> <span class="n">resolution_xyu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_type</span> <span class="o">=</span> <span class="n">img_type</span>

        <span class="c1"># Results fields #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">series</span> <span class="o">=</span> <span class="n">series</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aligned_img_shape_rc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Fields related to image pre-processing #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">brightfield_procsseing_fxn_str</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">if_procsseing_fxn_str</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">max_image_dim_px</span> <span class="o">&lt;</span> <span class="n">max_processed_image_dim_px</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;max_image_dim_px is </span><span class="si">{</span><span class="n">max_image_dim_px</span><span class="si">}</span><span class="s2"> but needs to be less or equal to </span><span class="si">{</span><span class="n">max_processed_image_dim_px</span><span class="si">}</span><span class="s2">. Setting max_image_dim_px to </span><span class="si">{</span><span class="n">max_processed_image_dim_px</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">max_image_dim_px</span> <span class="o">=</span> <span class="n">max_processed_image_dim_px</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span> <span class="o">=</span> <span class="n">max_image_dim_px</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_processed_image_dim_px</span> <span class="o">=</span> <span class="n">max_processed_image_dim_px</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_non_rigid_registartion_dim_px</span> <span class="o">=</span> <span class="n">max_non_rigid_registartion_dim_px</span>

        <span class="c1"># Setup rigid registration #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_img_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_img_f</span> <span class="o">=</span> <span class="n">reference_img_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_to_reference</span> <span class="o">=</span> <span class="n">align_to_reference</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">do_rigid</span> <span class="o">=</span> <span class="n">do_rigid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_registrar</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_rigid_reg_kwargs</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                                   <span class="n">feature_detector</span><span class="o">=</span><span class="n">feature_detector_cls</span><span class="p">,</span>
                                   <span class="n">similarity_metric</span><span class="o">=</span><span class="n">similarity_metric</span><span class="p">,</span>
                                   <span class="n">match_filter_method</span><span class="o">=</span><span class="n">match_filter_method</span><span class="p">,</span>
                                   <span class="n">transformer</span><span class="o">=</span><span class="n">transformer_cls</span><span class="p">,</span>
                                   <span class="n">affine_optimizer</span><span class="o">=</span><span class="n">affine_optimizer_cls</span><span class="p">,</span>
                                   <span class="n">imgs_ordered</span><span class="o">=</span><span class="n">imgs_ordered</span><span class="p">,</span>
                                   <span class="n">reference_img_f</span><span class="o">=</span><span class="n">reference_img_f</span><span class="p">,</span>
                                   <span class="n">qt_emitter</span><span class="o">=</span><span class="n">qt_emitter</span><span class="p">)</span>

        <span class="c1"># Setup non-rigid registration #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar_cls</span> <span class="o">=</span> <span class="n">non_rigid_registrar_cls</span>

        <span class="k">if</span> <span class="n">crop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reference_img_f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">crop</span> <span class="o">=</span> <span class="n">CROP_OVERLAP</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">crop</span> <span class="o">=</span> <span class="n">CROP_REF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">crop</span> <span class="o">=</span> <span class="n">crop</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compose_non_rigid</span> <span class="o">=</span> <span class="n">compose_non_rigid</span>
        <span class="k">if</span> <span class="n">non_rigid_registrar_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_non_rigid_reg_kwargs</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                                           <span class="n">non_rigid_reg_class</span><span class="o">=</span><span class="n">non_rigid_registrar_cls</span><span class="p">,</span>
                                           <span class="n">non_rigid_reg_params</span><span class="o">=</span><span class="n">non_rigid_reg_params</span><span class="p">,</span>
                                           <span class="n">reference_img_f</span><span class="o">=</span><span class="n">reference_img_f</span><span class="p">,</span>
                                           <span class="n">compose_non_rigid</span><span class="o">=</span><span class="n">compose_non_rigid</span><span class="p">,</span>
                                           <span class="n">qt_emitter</span><span class="o">=</span><span class="n">qt_emitter</span><span class="p">)</span>

        <span class="c1"># Info realted to saving images to view results #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask_dict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_masks</span> <span class="o">=</span> <span class="n">create_masks</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span> <span class="o">=</span> <span class="n">thumbnail_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_overlap_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_overlap_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_overlap_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">micro_reg_overlap_img</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">has_rounds</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="o">=</span> <span class="n">norm_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">summary_df</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_rigid_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_non_rigid_time</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_set_rigid_reg_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">feature_detector</span><span class="p">,</span> <span class="n">similarity_metric</span><span class="p">,</span>
                              <span class="n">match_filter_method</span><span class="p">,</span> <span class="n">transformer</span><span class="p">,</span> <span class="n">affine_optimizer</span><span class="p">,</span>
                              <span class="n">imgs_ordered</span><span class="p">,</span> <span class="n">reference_img_f</span><span class="p">,</span> <span class="n">qt_emitter</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Set rigid registration kwargs</span>
<span class="sd">        Keyword arguments will be passed to `serial_rigid.register_images`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">matcher</span> <span class="o">=</span> <span class="n">feature_matcher</span><span class="o">.</span><span class="n">Matcher</span><span class="p">(</span><span class="n">match_filter_method</span><span class="o">=</span><span class="n">match_filter_method</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">affine_optimizer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">afo</span> <span class="o">=</span> <span class="n">affine_optimizer</span><span class="p">(</span><span class="n">transform</span><span class="o">=</span><span class="n">transformer</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">afo</span> <span class="o">=</span> <span class="n">affine_optimizer</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">NAME_KEY</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
                                 <span class="n">FD_KEY</span><span class="p">:</span> <span class="n">feature_detector</span><span class="p">(),</span>
                                 <span class="n">SIM_METRIC_KEY</span><span class="p">:</span> <span class="n">similarity_metric</span><span class="p">,</span>
                                 <span class="n">TRANSFORMER_KEY</span><span class="p">:</span> <span class="n">transformer</span><span class="p">(),</span>
                                 <span class="n">MATCHER_KEY</span><span class="p">:</span> <span class="n">matcher</span><span class="p">,</span>
                                 <span class="n">AFFINE_OPTIMIZER_KEY</span><span class="p">:</span> <span class="n">afo</span><span class="p">,</span>
                                 <span class="n">REF_IMG_KEY</span><span class="p">:</span> <span class="n">reference_img_f</span><span class="p">,</span>
                                 <span class="n">IMAGES_ORDERD_KEY</span><span class="p">:</span> <span class="n">imgs_ordered</span><span class="p">,</span>
                                 <span class="n">QT_EMMITER_KEY</span><span class="p">:</span> <span class="n">qt_emitter</span>
                                 <span class="p">}</span>

        <span class="c1"># Save methods as strings since some objects cannot be pickled #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_descriptor_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="n">FD_KEY</span><span class="p">]</span><span class="o">.</span><span class="n">kp_descriptor_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_detector_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="n">FD_KEY</span><span class="p">]</span><span class="o">.</span><span class="n">kp_detector_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="n">TRANSFORMER_KEY</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">similarity_metric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="n">SIM_METRIC_KEY</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_filter_method</span> <span class="o">=</span> <span class="n">match_filter_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imgs_ordered</span> <span class="o">=</span> <span class="n">imgs_ordered</span>

    <span class="k">def</span> <span class="nf">_set_non_rigid_reg_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">non_rigid_reg_class</span><span class="p">,</span> <span class="n">non_rigid_reg_params</span><span class="p">,</span>
                                  <span class="n">reference_img_f</span><span class="p">,</span> <span class="n">compose_non_rigid</span><span class="p">,</span> <span class="n">qt_emitter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set non-rigid registration kwargs</span>
<span class="sd">        Keyword arguments will be passed to `serial_non_rigid.register_images`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_reg_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">NAME_KEY</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
                                     <span class="n">NON_RIGID_REG_CLASS_KEY</span><span class="p">:</span> <span class="n">non_rigid_reg_class</span><span class="p">,</span>
                                     <span class="n">NON_RIGID_REG_PARAMS_KEY</span><span class="p">:</span> <span class="n">non_rigid_reg_params</span><span class="p">,</span>
                                     <span class="n">REF_IMG_KEY</span><span class="p">:</span> <span class="n">reference_img_f</span><span class="p">,</span>
                                     <span class="n">QT_EMMITER_KEY</span><span class="p">:</span> <span class="n">qt_emitter</span><span class="p">,</span>
                                     <span class="n">NON_RIGID_COMPOSE_KEY</span><span class="p">:</span> <span class="n">compose_non_rigid</span>
                                     <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_reg_class_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_reg_kwargs</span><span class="p">[</span><span class="n">NON_RIGID_REG_CLASS_KEY</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span> <span class="nf">get_imgs_in_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all images in Valis.src_dir</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">full_path_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src_dir</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src_dir</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">img_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">full_path_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">get_img_type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="n">img_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">full_path_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="n">dir_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">is_round</span><span class="p">,</span> <span class="n">master_slide</span> <span class="o">=</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">determine_if_staining_round</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_round</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">master_slide</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Some formats, like .mrxs have the main file but</span>
                    <span class="c1"># data in a subdirectory with the same name</span>
                    <span class="n">matching_f</span> <span class="o">=</span> <span class="p">[</span><span class="n">ff</span> <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">full_path_list</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">dir_name</span><span class="p">,</span> <span class="n">ff</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ff</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dir_name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">matching_f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span><span class="p">:</span>
                            <span class="c1"># Make sure that file not already in list</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">matching_f</span><span class="p">)</span>
                            <span class="n">img_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dir_name</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_f</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">matching_f</span><span class="p">)</span><span class="si">}</span><span class="s2"> matches for </span><span class="si">{</span><span class="n">dir_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">matching_f</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Can&#39;t find slide file associated with </span><span class="si">{</span><span class="n">dir_name</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_dst_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set paths to where the results will be saved.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">img_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">CONVERTED_IMG_DIR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processed_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">PROCESSED_IMG_DIR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_dst_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">RIGID_REG_IMG_DIR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_dst_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">NON_RIGID_REG_IMG_DIR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deformation_field_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">DEFORMATION_FIELD_IMG_DIR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">OVERLAP_IMG_DIR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">REG_RESULTS_DATA_DIR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">displacements_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">DISPLACEMENT_DIRS</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">micro_reg_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">MICRO_REG_DIR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">MASK_DIR</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_ref_slide</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">ref_slide</span>

    <span class="k">def</span> <span class="nf">convert_imgs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reader_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert slides to images and create dictionary of Slides.</span>

<span class="sd">        series : int, optional</span>
<span class="sd">            Slide series to be read. If None, the series with largest image will be read</span>

<span class="sd">        reader_cls : SlideReader, optional</span>
<span class="sd">            Uninstantiated SlideReader class that will convert</span>
<span class="sd">            the slide to an image, and also collect metadata.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">img_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reader_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">reader_cls</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">get_slide_reader</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">)</span>

            <span class="n">reader</span> <span class="o">=</span> <span class="n">reader_cls</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="n">series</span><span class="p">)</span>

            <span class="n">slide_dims</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">slide_dimensions</span>
            <span class="n">levels_in_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">slide_dims</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels_in_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">levels_in_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">level</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">slide_dims</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">vips_img</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">slide2vips</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>

            <span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vips_img</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">vips_img</span><span class="o">.</span><span class="n">height</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">scaling</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">vips_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">rescale_img</span><span class="p">(</span><span class="n">vips_img</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)</span>

            <span class="n">img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">vips_img</span><span class="p">)</span>

            <span class="n">slide_obj</span> <span class="o">=</span> <span class="n">Slide</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">reader</span><span class="p">)</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">crop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop</span>
            <span class="n">img_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">img_type</span><span class="p">)</span>

            <span class="c1"># Will overwrite data if provided. Can occur if reading images, not the actual slides #</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dims_dict_wh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">matching_slide</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dims_dict_wh</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                                  <span class="k">if</span> <span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">slide_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dims_dict_wh</span><span class="p">[</span><span class="n">matching_slide</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">slide_dims</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">slide_dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">slide_dims</span><span class="p">]])</span>
                <span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_shape_rc</span> <span class="o">=</span> <span class="n">slide_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution_xyu</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">slide_obj</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution_xyu</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">slide_obj</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution_xyu</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">slide_obj</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unique_img_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">img_types</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_img_types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image_type</span> <span class="o">=</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">MULTI_MODAL_NAME</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image_type</span> <span class="o">=</span> <span class="n">unique_img_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_img_max_dims</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">check_img_max_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ensure that all images have similar sizes.</span>

<span class="sd">        `max_image_dim_px` will be set to the maximum dimension of the</span>
<span class="sd">        smallest image if that value is less than max_image_dim_px</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">og_img_sizes_wh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="n">img_max_dims</span> <span class="o">=</span> <span class="n">og_img_sizes_wh</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">min_max_wh</span> <span class="o">=</span> <span class="n">img_max_dims</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">scaling_for_og_imgs</span> <span class="o">=</span> <span class="n">min_max_wh</span><span class="o">/</span><span class="n">img_max_dims</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">scaling_for_og_imgs</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Smallest image is less than max_image_dim_px. parameter max_image_dim_px is being set to </span><span class="si">{</span><span class="n">min_max_wh</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span> <span class="o">=</span> <span class="n">min_max_wh</span>
            <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="c1"># Rescale images</span>
                <span class="n">scaling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">assert</span> <span class="n">scaling</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span>
                <span class="k">if</span> <span class="n">scaling</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span>  <span class="n">warp_tools</span><span class="o">.</span><span class="n">rescale_img</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_processed_image_dim_px</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;parameter max_processed_image_dim_px also being updated to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_processed_image_dim_px</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_image_dim_px</span>

    <span class="k">def</span> <span class="nf">create_original_composite_img</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rigid_registrar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create imaage showing how images overlap before registration</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">min_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">max_r</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">min_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">max_c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">composite_img_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">):</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">img_obj</span><span class="o">.</span><span class="n">image</span>
            <span class="n">padded_img</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">img_obj</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">output_shape</span><span class="o">=</span><span class="n">img_obj</span><span class="o">.</span><span class="n">padded_shape_rc</span><span class="p">)</span>

            <span class="n">composite_img_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">padded_img</span>

            <span class="n">img_corners_rc</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_corners_of_image</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">warped_corners_xy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">img_corners_rc</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">img_obj</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">min_r</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">warped_corners_xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">min_r</span><span class="p">)</span>
            <span class="n">max_r</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">warped_corners_xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">max_r</span><span class="p">)</span>
            <span class="n">min_c</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">warped_corners_xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">min_c</span><span class="p">)</span>
            <span class="n">max_c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">warped_corners_xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">max_c</span><span class="p">)</span>

        <span class="n">composite_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">composite_img_list</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">jzazbz_cmap</span><span class="p">()</span>
        <span class="n">channel_colors</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">get_n_colors</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">composite_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">overlap_img</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">color_multichannel</span><span class="p">(</span><span class="n">composite_img</span><span class="p">,</span> <span class="n">channel_colors</span><span class="p">,</span>
                                             <span class="n">rescale_channels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                             <span class="n">normalize_by</span><span class="o">=</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span>
                                             <span class="n">cspace</span><span class="o">=</span><span class="s2">&quot;CAM16UCS&quot;</span><span class="p">)</span>

        <span class="n">min_r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_r</span><span class="p">)</span>
        <span class="n">max_r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_r</span><span class="p">))</span>
        <span class="n">min_c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_c</span><span class="p">)</span>
        <span class="n">max_c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_c</span><span class="p">))</span>
        <span class="n">overlap_img</span> <span class="o">=</span> <span class="n">overlap_img</span><span class="p">[</span><span class="n">min_r</span><span class="p">:</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">:</span><span class="n">max_c</span><span class="p">]</span>
        <span class="n">overlap_img</span> <span class="o">=</span> <span class="p">(</span><span class="mi">255</span><span class="o">*</span><span class="n">overlap_img</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">overlap_img</span>

    <span class="k">def</span> <span class="nf">measure_original_mmi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img1</span><span class="p">,</span> <span class="n">img2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Measure Mattes mutation inormation between 2 unregistered images.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dst_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">img1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">img2</span><span class="o">.</span><span class="n">shape</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">padded_img_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">img1</span><span class="p">,</span> <span class="n">img2</span><span class="p">]):</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_padding_matrix</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dst_rc</span><span class="p">)</span>
            <span class="n">padded_img</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">output_shape</span><span class="o">=</span><span class="n">dst_rc</span><span class="p">)</span>
            <span class="n">padded_img_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">padded_img</span>

        <span class="n">og_mmi</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">mattes_mi</span><span class="p">(</span><span class="n">padded_img_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">padded_img_list</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">og_mmi</span>

    <span class="k">def</span> <span class="nf">process_imgs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">brightfield_processing_cls</span><span class="p">,</span> <span class="n">brightfield_processing_kwargs</span><span class="p">,</span>
                     <span class="n">if_processing_cls</span><span class="p">,</span> <span class="n">if_processing_kwargs</span><span class="p">):</span>

        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;Process images to make them look as similar as possible</span>

<span class="s2">        Images will also be normalized after images are processed</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        brightfield_processing_cls : ImageProcesser</span>
<span class="s2">            ImageProcesser to pre-process brightfield images to make them look as similar as possible.</span>
<span class="s2">            Should return a single channel uint8 image. The default function is</span>
<span class="s2">            </span><span class="si">{</span><span class="n">DEFAULT_BRIGHTFIELD_CLASS</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> will be used for</span>
<span class="s2">            `img_type` = </span><span class="si">{</span><span class="n">slide_tools</span><span class="o">.</span><span class="n">IHC_NAME</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">DEFAULT_BRIGHTFIELD_CLASS</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"></span>
<span class="s2">            is located in the preprocessing module.</span>

<span class="s2">        brightfield_processing_kwargs : dict</span>
<span class="s2">            Dictionary of keyward arguments to be passed to `ihc_processing_fxn`</span>

<span class="s2">        if_processing_fxn : ImageProcesser</span>
<span class="s2">            ImageProcesser to pre-process immunofluorescent images to make them look as similar as possible.</span>
<span class="s2">            Should return a single channel uint8 image. If None, then </span><span class="si">{</span><span class="n">DEFAULT_FLOURESCENCE_CLASS</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"></span>
<span class="s2">            will be used for `img_type` = </span><span class="si">{</span><span class="n">slide_tools</span><span class="o">.</span><span class="n">IF_NAME</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">DEFAULT_FLOURESCENCE_CLASS</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is</span>
<span class="s2">            located in the preprocessing module.</span>

<span class="s2">        if_processing_kwargs : dict</span>
<span class="s2">            Dictionary of keyward arguments to be passed to `if_processing_fxn`</span>

<span class="s2">        &quot;&quot;&quot;</span>

        <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="o">==</span> <span class="s2">&quot;histo_match&quot;</span><span class="p">:</span>
                <span class="n">ref_histogram</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_v</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
            <span class="n">is_ihc</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">img_type</span> <span class="o">==</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">IHC_NAME</span>
            <span class="k">if</span> <span class="n">is_ihc</span><span class="p">:</span>
                <span class="n">processing_cls</span> <span class="o">=</span> <span class="n">brightfield_processing_cls</span>
                <span class="n">processing_kwargs</span> <span class="o">=</span> <span class="n">brightfield_processing_kwargs</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">processing_cls</span> <span class="o">=</span> <span class="n">if_processing_cls</span>
                <span class="n">processing_kwargs</span> <span class="o">=</span> <span class="n">if_processing_kwargs</span>

            <span class="n">levels_in_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_processed_image_dim_px</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels_in_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">levels_in_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">level</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">processor</span> <span class="o">=</span> <span class="n">processing_cls</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">src_f</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">src_f</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">series</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">processed_img</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">process_image</span><span class="p">(</span><span class="o">**</span><span class="n">processing_kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># processor.process_image doesn&#39;t take kwargs</span>
                <span class="n">processed_img</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">process_image</span><span class="p">()</span>

            <span class="n">processed_img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">processed_img</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_processed_image_dim_px</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">processed_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">scaling</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">processed_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">rescale_img</span><span class="p">(</span><span class="n">processed_img</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_masks</span><span class="p">:</span>
                <span class="c1"># Get masks #</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Slice region from slide and process too</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">create_mask</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">processed_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">resize_img</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">processed_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>

                <span class="n">slide_obj</span><span class="o">.</span><span class="n">rigid_reg_mask</span> <span class="o">=</span> <span class="n">mask</span>
                <span class="n">processed_img</span><span class="p">[</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Save image with mask drawn on top of it</span>
                <span class="n">thumbnail_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_thumbnail</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">img_type</span> <span class="o">==</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">IHC_NAME</span><span class="p">:</span>
                    <span class="n">thumbnail_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_thumbnail</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">thumbnail_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_thumbnail</span><span class="p">(</span><span class="n">processed_img</span><span class="p">)</span>

                <span class="n">thumbnail_mask_outline</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">draw_outline</span><span class="p">(</span><span class="n">thumbnail_img</span><span class="p">,</span> <span class="n">thumbnail_mask</span><span class="p">)</span>
                <span class="n">outline_f_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.png&#39;</span><span class="p">)</span>
                <span class="n">warp_tools</span><span class="o">.</span><span class="n">save_img</span><span class="p">(</span><span class="n">outline_f_out</span><span class="p">,</span> <span class="n">thumbnail_mask_outline</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">slide_obj</span><span class="o">.</span><span class="n">rigid_reg_mask</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img</span> <span class="o">=</span> <span class="n">processed_img</span>

            <span class="n">processed_f_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_dir</span><span class="p">,</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span><span class="p">)</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_f</span> <span class="o">=</span> <span class="n">processed_f_out</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">processed_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">warp_tools</span><span class="o">.</span><span class="n">save_img</span><span class="p">(</span><span class="n">processed_f_out</span><span class="p">,</span> <span class="n">processed_img</span><span class="p">)</span>

            <span class="n">img_for_stats</span> <span class="o">=</span> <span class="n">processed_img</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="o">==</span> <span class="s2">&quot;histo_match&quot;</span><span class="p">:</span>
                    <span class="n">img_hist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">img_for_stats</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span>
                    <span class="n">ref_histogram</span> <span class="o">+=</span> <span class="n">img_hist</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">all_v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">img_for_stats</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="o">==</span> <span class="s2">&quot;histo_match&quot;</span><span class="p">:</span>
                <span class="n">target_stats</span> <span class="o">=</span> <span class="n">ref_histogram</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">all_v</span><span class="p">)</span>
                <span class="n">target_stats</span> <span class="o">=</span> <span class="n">all_v</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">normalize_images</span><span class="p">(</span><span class="n">target_stats</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">denoise_images</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
            <span class="k">if</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">rigid_reg_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">is_ihc</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">img_type</span> <span class="o">==</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">IHC_NAME</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">tissue_mask</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">create_tissue_mask</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">is_ihc</span><span class="p">)</span>
                <span class="n">mask_bbox</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">mask2xy</span><span class="p">(</span><span class="n">tissue_mask</span><span class="p">))</span>
                <span class="n">c0</span><span class="p">,</span> <span class="n">r0</span> <span class="o">=</span> <span class="n">mask_bbox</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">c1</span><span class="p">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">mask_bbox</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">mask_bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
                <span class="n">denoise_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">tissue_mask</span><span class="p">)</span>
                <span class="n">denoise_mask</span><span class="p">[</span><span class="n">r0</span><span class="p">:</span><span class="n">r1</span><span class="p">,</span> <span class="n">c0</span><span class="p">:</span><span class="n">c1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">denoise_mask</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">rigid_reg_mask</span>

            <span class="n">denoised</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">denoise_img</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">denoise_mask</span><span class="p">)</span>
            <span class="n">warp_tools</span><span class="o">.</span><span class="n">save_img</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_f</span><span class="p">,</span> <span class="n">denoised</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">normalize_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normalize intensity values in images</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target : ndarray</span>
<span class="sd">            Target statistics used to normalize images</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==== Normalizing images</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
            <span class="n">vips_img</span> <span class="o">=</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">new_from_file</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_f</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">vips_img</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="o">==</span> <span class="s2">&quot;histo_match&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_processing_stats</span> <span class="o">=</span> <span class="n">target</span>
                <span class="n">normed_img</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">match_histograms</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_processing_stats</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_method</span> <span class="o">==</span> <span class="s2">&quot;img_stats&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">target_processing_stats</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">get_channel_stats</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                <span class="n">normed_img</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">norm_img_stats</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_processing_stats</span><span class="p">)</span>

            <span class="n">normed_img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">normed_img</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img</span> <span class="o">=</span> <span class="n">normed_img</span>

            <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">normed_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">warp_tools</span><span class="o">.</span><span class="n">save_img</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_f</span><span class="p">,</span> <span class="n">normed_img</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create_thumbnail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">rescale_color</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create thumbnail image to view results</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">scaling</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">thumbnail</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">rescale_img</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thumbnail</span> <span class="o">=</span> <span class="n">img</span>

        <span class="k">if</span> <span class="n">rescale_color</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">thumbnail</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">thumbnail</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">thumbnail</span>

    <span class="k">def</span> <span class="nf">draw_overlap_img</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create image showing the overlap of registered images</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">composite_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">img_list</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">jzazbz_cmap</span><span class="p">()</span>
        <span class="n">channel_colors</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">get_n_colors</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">composite_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">overlap_img</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">color_multichannel</span><span class="p">(</span><span class="n">composite_img</span><span class="p">,</span> <span class="n">channel_colors</span><span class="p">,</span>
                                             <span class="n">rescale_channels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                             <span class="n">normalize_by</span><span class="o">=</span><span class="s2">&quot;channel&quot;</span><span class="p">,</span>
                                             <span class="n">cspace</span><span class="o">=</span><span class="s2">&quot;CAM16UCS&quot;</span><span class="p">)</span>

        <span class="n">overlap_img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">equalize_adapthist</span><span class="p">(</span><span class="n">overlap_img</span><span class="p">)</span>
        <span class="n">overlap_img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">overlap_img</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">overlap_img</span>

    <span class="k">def</span> <span class="nf">get_ref_img_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rigid_registrar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create mask that covers reference image</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : ndarray</span>
<span class="sd">            Mask that covers reference image in registered images</span>
<span class="sd">        mask_bbox_xywh : tuple of int</span>
<span class="sd">            XYWH of mask in reference image</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_slide</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>
        <span class="n">ref_shape_wh</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">uw_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">ref_shape_wh</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">255</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">uw_mask</span><span class="p">,</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                   <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">registered_shape_rc</span><span class="p">)</span>

        <span class="n">reg_txy</span> <span class="o">=</span> <span class="o">-</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">mask_bbox_xywh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="n">reg_txy</span><span class="p">,</span> <span class="o">*</span><span class="n">ref_shape_wh</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask_bbox_xywh</span>

    <span class="k">def</span> <span class="nf">get_all_overlap_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rigid_registrar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create mask that covers intersection of all images</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : ndarray</span>
<span class="sd">            Mask that covers reference image in registered images</span>
<span class="sd">        mask_bbox_xywh : tuple of int</span>
<span class="sd">            XYWH of mask in reference image</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ref_slide</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">registered_shape_rc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">:</span>
            <span class="n">img_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">warped_img_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img_mask</span><span class="p">,</span>
                                                  <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                  <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">registered_shape_rc</span><span class="p">,</span>
                                                  <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">+=</span> <span class="n">warped_img_mask</span>

        <span class="n">mask</span><span class="p">[</span><span class="n">mask</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="n">mask_bbox_xywh</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">mask2xy</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask_bbox_xywh</span>

    <span class="k">def</span> <span class="nf">get_null_overlap_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rigid_registrar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create mask that covers all of the image.</span>
<span class="sd">        Not really a mask</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : ndarray</span>
<span class="sd">            Mask that covers reference image in registered images</span>
<span class="sd">        mask_bbox_xywh : tuple of int</span>
<span class="sd">            XYWH of mask in reference image</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reg_shape</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">registered_shape_rc</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">reg_shape</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">mask_bbox_xywh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">reg_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reg_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask_bbox_xywh</span>

    <span class="k">def</span> <span class="nf">create_crop_masks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rigid_registrar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create masks based on rigid registration</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">mask_dict</span><span class="p">[</span><span class="n">CROP_REF</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">get_ref_img_mask</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="p">)</span>
        <span class="n">mask_dict</span><span class="p">[</span><span class="n">CROP_OVERLAP</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all_overlap_mask</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="p">)</span>
        <span class="n">mask_dict</span><span class="p">[</span><span class="n">CROP_NONE</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_null_overlap_mask</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask_dict</span> <span class="o">=</span> <span class="n">mask_dict</span>

    <span class="k">def</span> <span class="nf">get_crop_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overlap_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get overlap mask and bounding box</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : ndarray</span>
<span class="sd">            Mask</span>

<span class="sd">        mask_xywh : tuple</span>
<span class="sd">            XYWH for bounding box around mask</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">overlap_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">overlap_type</span> <span class="o">=</span> <span class="n">CROP_NONE</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_dict</span><span class="p">[</span><span class="n">overlap_type</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">rigid_register_partial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tform_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform rigid registration using provided parameters</span>

<span class="sd">        Still sorts images by similarity for use with non-rigid registration.</span>

<span class="sd">        tform_dict : dictionary</span>
<span class="sd">            Dictionary with rigid registration parameters. Each key is the image&#39;s file name, and</span>
<span class="sd">            the values are another dictionary with transformation parameters:</span>
<span class="sd">                M: 3x3 inverse transformation matrix. Found by determining how to align fixed to moving.</span>
<span class="sd">                    If M was found by determining how to align moving to fixed, then it will need to be inverted</span>

<span class="sd">                transformation_src_shape_rc: shape (row, col) of image used to find the rigid transformation. If</span>
<span class="sd">                    not provided, then it is assumed to be the shape of the level 0 slide</span>
<span class="sd">                transformation_dst_shape_rc: shape of registered image. If not presesnt, but a reference was provided</span>
<span class="sd">                    and `transformation_src_shape_rc` was not provided, this is assumed to be the shape of the reference slide</span>

<span class="sd">            If None, then all rigid M will be the identity matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1"># Still need to sort images #</span>
        <span class="n">rigid_registrar</span> <span class="o">=</span> <span class="n">serial_rigid</span><span class="o">.</span><span class="n">SerialRigidRegistrar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_dir</span><span class="p">,</span>
                                        <span class="n">imgs_ordered</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">imgs_ordered</span><span class="p">,</span>
                                        <span class="n">reference_img_f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">,</span>
                                        <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                        <span class="n">align_to_reference</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">align_to_reference</span><span class="p">)</span>

        <span class="n">feature_detector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="n">FD_KEY</span><span class="p">]</span>
        <span class="n">matcher</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="n">MATCHER_KEY</span><span class="p">]</span>
        <span class="n">similarity_metric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="n">SIM_METRIC_KEY</span><span class="p">]</span>
        <span class="n">transformer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="n">TRANSFORMER_KEY</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">======== Detecting features</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">generate_img_obj_list</span><span class="p">(</span><span class="n">feature_detector</span><span class="p">)</span>


        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">======== Matching images</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">aleady_sorted</span><span class="p">:</span>
            <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">match_sorted_imgs</span><span class="p">(</span><span class="n">matcher</span><span class="p">,</span> <span class="n">keep_unfiltered</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">):</span>
                <span class="n">img_obj</span><span class="o">.</span><span class="n">stack_idx</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">match_imgs</span><span class="p">(</span><span class="n">matcher</span><span class="p">,</span> <span class="n">keep_unfiltered</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">======== Sorting images</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">build_metric_matrix</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">similarity_metric</span><span class="p">)</span>
            <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">distance_metric_name</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">metric_name</span>
        <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">distance_metric_type</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">metric_type</span>
        <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">get_iter_order</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">update_match_dicts_with_neighbor_filter</span><span class="p">(</span><span class="n">transformer</span><span class="p">,</span> <span class="n">matcher</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_img_f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref_name</span> <span class="o">=</span> <span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref_name</span> <span class="o">=</span> <span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_rigid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;Best to specify `</span><span class="si">{</span><span class="n">REF_IMG_KEY</span><span class="si">}</span><span class="s2">` when manually providing `</span><span class="si">{</span><span class="n">TFORM_MAT_KEY</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">,</span>
                       <span class="sa">f</span><span class="s2">&quot;Setting this image to be </span><span class="si">{</span><span class="n">ref_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span>

                <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Get output shapes #</span>
        <span class="k">if</span> <span class="n">tform_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">named_tform_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">o</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;M&quot;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)}</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">named_tform_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">k</span><span class="p">):</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tform_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># Get output shapes #</span>
        <span class="n">rigid_ref_obj</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_dict</span><span class="p">[</span><span class="n">ref_name</span><span class="p">]</span>
        <span class="n">ref_slide_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">ref_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ref_name</span> <span class="ow">in</span> <span class="n">named_tform_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">ref_tforms</span> <span class="o">=</span> <span class="n">named_tform_dict</span><span class="p">[</span><span class="n">ref_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">TFORM_SRC_SHAPE_KEY</span> <span class="ow">in</span> <span class="n">ref_tforms</span><span class="p">:</span>
                <span class="n">ref_tform_src_shape_rc</span> <span class="o">=</span> <span class="n">ref_tforms</span><span class="p">[</span><span class="n">TFORM_SRC_SHAPE_KEY</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ref_tform_src_shape_rc</span> <span class="o">=</span> <span class="n">ref_slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">TFORM_DST_SHAPE_KEY</span> <span class="ow">in</span> <span class="n">ref_tforms</span><span class="p">:</span>
                <span class="n">temp_out_shape_rc</span> <span class="o">=</span> <span class="n">ref_tforms</span><span class="p">[</span><span class="n">TFORM_DST_SHAPE_KEY</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Assume M was found by aligning to level 0 reference</span>
                <span class="n">temp_out_shape_rc</span> <span class="o">=</span> <span class="n">ref_slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">ref_to_reg_sxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rigid_ref_obj</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_tform_src_shape_rc</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">out_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">temp_out_shape_rc</span><span class="o">*</span><span class="n">ref_to_reg_sxy</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref_slide_shape_rc</span> <span class="o">=</span> <span class="n">ref_slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ref_to_reg_sxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rigid_ref_obj</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_slide_shape_rc</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">out_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ref_slide_shape_rc</span><span class="o">*</span><span class="n">ref_to_reg_sxy</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">scaled_M_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">img_name</span><span class="p">,</span> <span class="n">img_tforms</span> <span class="ow">in</span> <span class="n">named_tform_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">matching_rigid_obj</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_dict</span><span class="p">[</span><span class="n">img_name</span><span class="p">]</span>
            <span class="n">matching_slide_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">img_name</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">TFORM_SRC_SHAPE_KEY</span> <span class="ow">in</span> <span class="n">img_tforms</span><span class="p">:</span>
                <span class="n">og_src_shape_rc</span> <span class="o">=</span> <span class="n">img_tforms</span><span class="p">[</span><span class="n">TFORM_SRC_SHAPE_KEY</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">og_src_shape_rc</span> <span class="o">=</span> <span class="n">matching_slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">temp_M</span> <span class="o">=</span> <span class="n">img_tforms</span><span class="p">[</span><span class="n">TFORM_MAT_KEY</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">temp_M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">temp_M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">temp_M</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

            <span class="k">if</span> <span class="n">TFORM_DST_SHAPE_KEY</span> <span class="ow">in</span> <span class="n">img_tforms</span><span class="p">:</span>
                <span class="n">og_dst_shape_rc</span> <span class="o">=</span> <span class="n">img_tforms</span><span class="p">[</span><span class="n">TFORM_DST_SHAPE_KEY</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">og_dst_shape_rc</span> <span class="o">=</span> <span class="n">ref_slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">img_corners_xy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_corners_of_image</span><span class="p">(</span><span class="n">matching_rigid_obj</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">warped_corners</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">img_corners_xy</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">temp_M</span><span class="p">,</span>
                                    <span class="n">transformation_src_shape_rc</span><span class="o">=</span><span class="n">og_src_shape_rc</span><span class="p">,</span>
                                    <span class="n">transformation_dst_shape_rc</span><span class="o">=</span><span class="n">og_dst_shape_rc</span><span class="p">,</span>
                                    <span class="n">src_shape_rc</span><span class="o">=</span><span class="n">matching_rigid_obj</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                    <span class="n">dst_shape_rc</span><span class="o">=</span><span class="n">out_rc</span><span class="p">)</span>
            <span class="n">M_tform</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">ProjectiveTransform</span><span class="p">()</span>
            <span class="n">M_tform</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">warped_corners</span><span class="p">,</span> <span class="n">img_corners_xy</span><span class="p">)</span>
            <span class="n">for_reg_M</span> <span class="o">=</span> <span class="n">M_tform</span><span class="o">.</span><span class="n">params</span>
            <span class="n">scaled_M_dict</span><span class="p">[</span><span class="n">matching_rigid_obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">for_reg_M</span>
            <span class="n">matching_rigid_obj</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">for_reg_M</span>

        <span class="c1"># Find M if not provided</span>
        <span class="k">for</span> <span class="n">moving_idx</span><span class="p">,</span> <span class="n">fixed_idx</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="o">.</span><span class="n">iter_order</span><span class="p">):</span>
            <span class="n">img_obj</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">[</span><span class="n">moving_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">img_obj</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">scaled_M_dict</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">prev_img_obj</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">[</span><span class="n">fixed_idx</span><span class="p">]</span>
            <span class="n">img_obj</span><span class="o">.</span><span class="n">fixed_obj</span> <span class="o">=</span> <span class="n">prev_img_obj</span>

            <span class="k">if</span> <span class="n">fixed_idx</span> <span class="o">==</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">reference_img_idx</span><span class="p">:</span>
                <span class="n">prev_M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

            <span class="n">to_prev_match_info</span> <span class="o">=</span> <span class="n">img_obj</span><span class="o">.</span><span class="n">match_dict</span><span class="p">[</span><span class="n">prev_img_obj</span><span class="p">]</span>
            <span class="n">src_xy</span> <span class="o">=</span> <span class="n">to_prev_match_info</span><span class="o">.</span><span class="n">matched_kp1_xy</span>
            <span class="n">dst_xy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">to_prev_match_info</span><span class="o">.</span><span class="n">matched_kp2_xy</span><span class="p">,</span> <span class="n">prev_M</span><span class="p">)</span>

            <span class="n">transformer</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">dst_xy</span><span class="p">,</span> <span class="n">src_xy</span><span class="p">)</span>
            <span class="n">img_obj</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">params</span>

            <span class="n">prev_M</span> <span class="o">=</span> <span class="n">img_obj</span><span class="o">.</span><span class="n">M</span>

        <span class="c1"># Add registered image</span>
        <span class="k">for</span> <span class="n">img_obj</span> <span class="ow">in</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">:</span>
            <span class="n">img_obj</span><span class="o">.</span><span class="n">M_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">img_obj</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>

            <span class="n">img_obj</span><span class="o">.</span><span class="n">registered_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">img_obj</span><span class="o">.</span><span class="n">image</span><span class="p">,</span>
                                                        <span class="n">M</span><span class="o">=</span><span class="n">img_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                        <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">out_rc</span><span class="p">)</span>

            <span class="n">img_obj</span><span class="o">.</span><span class="n">registered_shape_rc</span> <span class="o">=</span> <span class="n">img_obj</span><span class="o">.</span><span class="n">registered_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">rigid_registrar</span>

    <span class="k">def</span> <span class="nf">rigid_register</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rigidly register slides</span>

<span class="sd">        Also saves thumbnails of rigidly registered images.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rigid_registrar : SerialRigidRegistrar</span>
<span class="sd">            SerialRigidRegistrar object that performed the rigid registration.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">denoise</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">denoise</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">denoise_images</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_rigid</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">rigid_registrar</span> <span class="o">=</span> <span class="n">serial_rigid</span><span class="o">.</span><span class="n">register_images</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_dir</span><span class="p">,</span>
                                                        <span class="n">align_to_reference</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">align_to_reference</span><span class="p">,</span>
                                                        <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">do_rigid</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="c1"># User provided transforms</span>
                <span class="n">rigid_tforms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_rigid</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_rigid</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># Skip rigid registration</span>
                <span class="n">rigid_tforms</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">rigid_registrar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_register_partial</span><span class="p">(</span><span class="n">tform_dict</span><span class="o">=</span><span class="n">rigid_tforms</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">end_rigid_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_registrar</span> <span class="o">=</span> <span class="n">rigid_registrar</span>
        <span class="k">if</span> <span class="n">rigid_registrar</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Rigid registration failed&quot;</span>
            <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Draw and save overlap image #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aligned_img_shape_rc</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">registered_shape_rc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_img_idx</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">reference_img_idx</span>
        <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="o">.</span><span class="n">reference_img_f</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_img_f</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">src_f</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">create_crop_masks</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="p">)</span>
        <span class="n">overlap_mask</span><span class="p">,</span> <span class="n">overlap_mask_bbox_xywh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crop_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">)</span>

        <span class="n">overlap_mask_bbox_xywh</span> <span class="o">=</span> <span class="n">overlap_mask_bbox_xywh</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>


        <span class="c1"># Create original overlap image #</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_overlap_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_original_composite_img</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="p">)</span>

        <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">original_overlap_img_fout</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_original_overlap.png&quot;</span><span class="p">)</span>
        <span class="n">warp_tools</span><span class="o">.</span><span class="n">save_img</span><span class="p">(</span><span class="n">original_overlap_img_fout</span><span class="p">,</span>  <span class="bp">self</span><span class="o">.</span><span class="n">original_overlap_img</span><span class="p">,</span> <span class="n">thumbnail_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="p">)</span>

        <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_dst_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span>  <span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span>  <span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Update attributes in slide_obj #</span>
        <span class="n">n_digits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">slide_reg_obj</span> <span class="ow">in</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">:</span>
            <span class="n">slide_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">M</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">stack_idx</span> <span class="o">=</span> <span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">stack_idx</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">reg_img_shape_rc</span> <span class="o">=</span> <span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">registered_img</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">rigid_reg_img_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_dst_dir</span><span class="p">,</span>
                                                     <span class="nb">str</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">stack_idx</span><span class="p">),</span> <span class="n">n_digits</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Won&#39;t know if single channel image is processed RGB (bight bg) or IF channel (dark bg)</span>
                <span class="n">slide_obj</span><span class="o">.</span><span class="n">get_bg_color_px_pos</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">stack_idx</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_img_idx</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">fixed_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">fixed_obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">fixed_slide</span> <span class="o">=</span> <span class="n">fixed_slide</span>

            <span class="n">match_dict</span> <span class="o">=</span> <span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">match_dict</span><span class="p">[</span><span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">fixed_obj</span><span class="p">]</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_matched_to_prev</span> <span class="o">=</span> <span class="n">match_dict</span><span class="o">.</span><span class="n">matched_kp1_xy</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_in_prev</span> <span class="o">=</span> <span class="n">match_dict</span><span class="o">.</span><span class="n">matched_kp2_xy</span>

            <span class="c1"># Get points in overlap box #</span>
            <span class="n">prev_kp_warped_for_bbox_test</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_in_prev</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">prev_kp_in_bbox_idx</span> <span class="o">=</span> \
                <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_pts_in_bbox</span><span class="p">(</span><span class="n">prev_kp_warped_for_bbox_test</span><span class="p">,</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">)</span>

            <span class="n">current_kp_warped_for_bbox_test</span> <span class="o">=</span> \
                <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_matched_to_prev</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">current_kp_in_bbox_idx</span> <span class="o">=</span> \
                <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_pts_in_bbox</span><span class="p">(</span><span class="n">current_kp_warped_for_bbox_test</span><span class="p">,</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">)</span>

            <span class="n">matched_kp_in_bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">prev_kp_in_bbox_idx</span><span class="p">,</span> <span class="n">current_kp_in_bbox_idx</span><span class="p">)</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_matched_to_prev_in_bbox</span> <span class="o">=</span>  <span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_matched_to_prev</span><span class="p">[</span><span class="n">matched_kp_in_bbox</span><span class="p">]</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_in_prev_in_bbox</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_in_prev</span><span class="p">[</span><span class="n">matched_kp_in_bbox</span><span class="p">]</span>


        <span class="k">if</span> <span class="n">denoise</span><span class="p">:</span>
            <span class="c1"># Processed image may have been denoised for rigid registration. Replace with unblurred image</span>
            <span class="k">for</span> <span class="n">img_obj</span> <span class="ow">in</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">:</span>
                <span class="n">matching_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">img_obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="n">reg_img</span> <span class="o">=</span> <span class="n">matching_slide</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">matching_slide</span><span class="o">.</span><span class="n">processed_img</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">img_obj</span><span class="o">.</span><span class="n">registered_img</span> <span class="o">=</span> <span class="n">reg_img</span>
                <span class="n">img_obj</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">matching_slide</span><span class="o">.</span><span class="n">processed_img</span>

        <span class="n">rigid_img_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">img_obj</span><span class="o">.</span><span class="n">registered_img</span> <span class="k">for</span> <span class="n">img_obj</span> <span class="ow">in</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_overlap_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_overlap_img</span><span class="p">(</span><span class="n">rigid_img_list</span><span class="p">)</span><span class="c1">#[overlap_min_r:overlap_max_r, overlap_min_c:overlap_max_c]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_overlap_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">crop_img</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rigid_overlap_img</span><span class="p">,</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">)</span>

        <span class="n">rigid_overlap_img_fout</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_rigid_overlap.png&quot;</span><span class="p">)</span>
        <span class="n">warp_tools</span><span class="o">.</span><span class="n">save_img</span><span class="p">(</span><span class="n">rigid_overlap_img_fout</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_overlap_img</span><span class="p">,</span> <span class="n">thumbnail_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="p">)</span>

        <span class="c1"># Overwrite black and white processed images #</span>
        <span class="k">for</span> <span class="n">slide_name</span><span class="p">,</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">slide_reg_obj</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_dict</span><span class="p">[</span><span class="n">slide_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">is_rgb</span><span class="p">:</span>
                <span class="n">img_to_warp</span> <span class="o">=</span> <span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">image</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">img_to_warp</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span>

            <span class="n">warped_img</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img_to_warp</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">)</span>
            <span class="n">warp_tools</span><span class="o">.</span><span class="n">save_img</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">rigid_reg_img_f</span><span class="p">,</span> <span class="n">warped_img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span> <span class="n">thumbnail_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="p">)</span>

            <span class="c1"># Replace processed image with a thumbnail #</span>
            <span class="n">warp_tools</span><span class="o">.</span><span class="n">save_img</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_f</span><span class="p">,</span> <span class="n">slide_reg_obj</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">thumbnail_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rigid_registrar</span>

    <span class="k">def</span> <span class="nf">create_non_rigid_reg_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get mask for non-rigid registration</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">any_rigid_reg_masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">rigid_reg_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="k">if</span> <span class="n">any_rigid_reg_masks</span><span class="p">:</span>
            <span class="n">non_rigid_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_non_rigid_reg_mask_from_rigid_masks</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">non_rigid_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_non_rigid_reg_mask_from_bbox</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">non_rigid_reg_mask</span> <span class="o">=</span> <span class="n">non_rigid_mask</span>

        <span class="c1"># Save thumbnail of mask</span>
        <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ref_slide</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">img_type</span> <span class="o">==</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">IHC_NAME</span><span class="p">:</span>
            <span class="n">warped_ref_img</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="n">CROP_REF</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warped_ref_img</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">processed_img</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="n">CROP_REF</span><span class="p">)</span>

        <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">thumbnail_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_thumbnail</span><span class="p">(</span><span class="n">warped_ref_img</span><span class="p">)</span>

        <span class="n">draw_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">resize_img</span><span class="p">(</span><span class="n">non_rigid_mask</span><span class="p">,</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span> <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">overlap_mask_bbox_xywh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crop_mask</span><span class="p">(</span><span class="n">CROP_REF</span><span class="p">)</span>
        <span class="n">draw_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">crop_img</span><span class="p">(</span><span class="n">draw_mask</span><span class="p">,</span> <span class="n">overlap_mask_bbox_xywh</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">thumbnail_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_thumbnail</span><span class="p">(</span><span class="n">draw_mask</span><span class="p">)</span>

        <span class="n">thumbnail_mask_outline</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">draw_outline</span><span class="p">(</span><span class="n">thumbnail_img</span><span class="p">,</span> <span class="n">thumbnail_mask</span><span class="p">)</span>
        <span class="n">outline_f_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_non_rigid_mask.png&#39;</span><span class="p">)</span>
        <span class="n">warp_tools</span><span class="o">.</span><span class="n">save_img</span><span class="p">(</span><span class="n">outline_f_out</span><span class="p">,</span> <span class="n">thumbnail_mask_outline</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_non_rigid_reg_mask_from_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mask will be bounding box of image overlaps</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ref_slide</span><span class="p">()</span>
        <span class="n">combo_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">img_bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">rigid_mask</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img_bbox</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
            <span class="n">combo_mask</span><span class="p">[</span><span class="n">rigid_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">overlap_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">combo_mask</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">overlap_bbox</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">mask2xy</span><span class="p">(</span><span class="n">overlap_mask</span><span class="p">))</span>
        <span class="n">c0</span><span class="p">,</span> <span class="n">r0</span> <span class="o">=</span> <span class="n">overlap_bbox</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">c1</span><span class="p">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">overlap_bbox</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">overlap_bbox</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

        <span class="n">non_rigid_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">overlap_mask</span><span class="p">)</span>
        <span class="n">non_rigid_mask</span><span class="p">[</span><span class="n">r0</span><span class="p">:</span><span class="n">r1</span><span class="p">,</span> <span class="n">c0</span><span class="p">:</span><span class="n">c1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>

        <span class="k">return</span> <span class="n">non_rigid_mask</span>


    <span class="k">def</span> <span class="nf">_create_non_rigid_reg_mask_from_rigid_masks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get mask that will cover all tissue. Use hysteresis thresholding to ignore</span>
<span class="sd">        masked regions found in only 1 image.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ref_slide</span><span class="p">()</span>
        <span class="n">combo_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">rigid_mask</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">rigid_reg_mask</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
            <span class="n">combo_mask</span><span class="p">[</span><span class="n">rigid_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">temp_non_rigid_mask</span> <span class="o">=</span> <span class="mi">255</span><span class="o">*</span><span class="n">filters</span><span class="o">.</span><span class="n">apply_hysteresis_threshold</span><span class="p">(</span><span class="n">combo_mask</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

        <span class="c1"># Draw convex hull around each region</span>
        <span class="n">non_rigid_mask</span> <span class="o">=</span> <span class="mi">255</span><span class="o">*</span><span class="n">ndimage</span><span class="o">.</span><span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">temp_non_rigid_mask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">non_rigid_mask</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">mask2contours</span><span class="p">(</span><span class="n">non_rigid_mask</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">non_rigid_mask</span>

    <span class="k">def</span> <span class="nf">pad_displacement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dxdy</span><span class="p">,</span> <span class="n">out_shape_rc</span><span class="p">,</span> <span class="n">bbox_xywh</span><span class="p">):</span>

        <span class="n">is_array</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dxdy</span><span class="p">,</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_array</span><span class="p">:</span>
            <span class="n">vips_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">dxdy</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vips_dxdy</span> <span class="o">=</span> <span class="n">dxdy</span>

        <span class="n">full_dxdy</span> <span class="o">=</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">black</span><span class="p">(</span><span class="n">out_shape_rc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out_shape_rc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bands</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
        <span class="n">full_dxdy</span> <span class="o">=</span> <span class="n">full_dxdy</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">vips_dxdy</span><span class="p">,</span> <span class="o">*</span><span class="n">bbox_xywh</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">is_array</span><span class="p">:</span>
            <span class="n">full_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">full_dxdy</span><span class="p">)</span>
            <span class="n">full_dxdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">full_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">full_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">full_dxdy</span>

    <span class="k">def</span> <span class="nf">prep_images_for_large_non_rigid_registration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_img_dim</span><span class="p">,</span>
                                                        <span class="n">brightfield_processing_cls</span><span class="p">,</span>
                                                        <span class="n">brightfield_processing_kwargs</span><span class="p">,</span>
                                                        <span class="n">if_processing_cls</span><span class="p">,</span>
                                                        <span class="n">if_processing_kwargs</span><span class="p">,</span>
                                                        <span class="n">updating_non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                        <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scale and process images for non-rigid registration using larger images</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_img_dim : int, optional</span>
<span class="sd">            Maximum size of image to be used for non-rigid registration. If None, the whole image</span>
<span class="sd">            will be used  for non-rigid registration</span>

<span class="sd">        brightfield_processing_fxn : callable</span>
<span class="sd">            Function to pre-process brightfield images to make them look as similar as possible.</span>
<span class="sd">            Should return a single channel uint8 image.</span>

<span class="sd">        brightfield_processing_kwargs : dict</span>
<span class="sd">            Dictionary of keyward arguments to be passed to `ihc_processing_fxn`</span>

<span class="sd">        if_processing_fxn : callable</span>
<span class="sd">            Function to pre-process immunofluorescent images to make them look as similar as possible.</span>
<span class="sd">            Should return a single channel uint8 image.</span>

<span class="sd">        if_processing_kwargs : dict</span>
<span class="sd">            Dictionary of keyward arguments to be passed to `if_processing_fxn`</span>

<span class="sd">        updating_non_rigid : bool, optional</span>
<span class="sd">            If `True`, the slide&#39;s current non-rigid registration will be applied</span>
<span class="sd">            The new displacements found using these larger images can therefore be used</span>
<span class="sd">            to update existing dxdy. If `False`, only the rigid transform will be applied,</span>
<span class="sd">            so this will be the first non-rigid transformation.</span>

<span class="sd">        mask : ndarray, optional</span>
<span class="sd">            Binary image indicating where to perform the non-rigid registration. Should be</span>
<span class="sd">            based off an already registered image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        img_dict : dictionary</span>
<span class="sd">            Dictionary that can be passed to a non-rigid registrar</span>

<span class="sd">        max_img_dim : int</span>
<span class="sd">            Maximum size of image to do non-rigid registration on. May be different</span>
<span class="sd">            if the requested size was too big</span>

<span class="sd">        scaled_non_rigid_mask : ndarray</span>
<span class="sd">            Scaled mask to use for non-rigid registration</span>

<span class="sd">        full_out_shape : ndarray of int</span>
<span class="sd">            Shape (row, col) of the warped images, without cropping</span>

<span class="sd">        mask_bbox_xywh : list</span>
<span class="sd">            Bounding box of `mask`. If `mask` is None, then so will `mask_bbox_xywh`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">warp_full_img</span> <span class="o">=</span> <span class="n">max_img_dim</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">warp_full_img</span><span class="p">:</span>
            <span class="n">all_max_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">max_img_dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">all_max_dims</span><span class="p">):</span>
                <span class="n">img_maxes</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
                <span class="n">smallest_img_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">img_maxes</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Requested size of images for non-rigid registration was </span><span class="si">{</span><span class="n">max_img_dim</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;However, not all images are this large. Setting `max_non_rigid_registartion_dim_px` to &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">smallest_img_max</span><span class="si">}</span><span class="s2">, which is the largest dimension of the smallest image&quot;</span><span class="p">)</span>
                <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">max_img_dim</span> <span class="o">=</span> <span class="n">smallest_img_max</span>

        <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ref_slide</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>
                <span class="n">mask_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">mask</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">width</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># Determine size of warped image/ROI</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">warp_full_img</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">max_img_dim</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If there is a mask then want its scaled bounding box to be == max_img_dim</span>
                <span class="n">to_reg_mask_sxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask_shape_rc</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">to_reg_mask_sxy</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># Resize just in case it&#39;s huge. Only need bounding box</span>
                    <span class="n">reg_size_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">resize_img</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span> <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">reg_size_mask</span> <span class="o">=</span> <span class="n">mask</span>
                <span class="n">reg_size_mask_xy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">mask2xy</span><span class="p">(</span><span class="n">reg_size_mask</span><span class="p">)</span>
                <span class="n">to_reg_mask_bbox_xywh</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span><span class="n">reg_size_mask_xy</span><span class="p">))</span>
                <span class="n">to_reg_mask_wh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">to_reg_mask_bbox_xywh</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">max_img_dim</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">to_reg_mask_wh</span><span class="p">))</span>

            <span class="n">max_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">max_s</span><span class="p">:</span>
                <span class="n">full_out_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_aligned_slide_shape</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">full_out_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_aligned_slide_shape</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Will register full size</span>
            <span class="n">full_out_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_aligned_slide_shape</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_shape</span> <span class="o">=</span> <span class="n">full_out_shape</span>
            <span class="n">mask_bbox_xywh</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If masking, the area will be smaller. Get bounding box</span>
            <span class="n">mask_sxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">full_out_shape</span><span class="o">/</span><span class="n">mask_shape_rc</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mask_bbox_xywh</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span><span class="n">mask_sxy</span><span class="o">*</span><span class="n">reg_size_mask_xy</span><span class="p">))</span>
            <span class="n">mask_bbox_xywh</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">mask_bbox_xywh</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">out_shape</span> <span class="o">=</span> <span class="n">mask_bbox_xywh</span><span class="p">[</span><span class="mi">2</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>
                <span class="n">vips_micro_reg_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vips_micro_reg_mask</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="n">vips_micro_reg_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">resize_img</span><span class="p">(</span><span class="n">vips_micro_reg_mask</span><span class="p">,</span> <span class="n">full_out_shape</span><span class="p">,</span> <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
            <span class="n">vips_micro_reg_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">crop_img</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">vips_micro_reg_mask</span><span class="p">,</span> <span class="n">xywh</span><span class="o">=</span><span class="n">mask_bbox_xywh</span><span class="p">)</span>

        <span class="n">use_tiler</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">bf_datatype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np_dtype</span> <span class="o">=</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">BF_FORMAT_NUMPY_DTYPE</span><span class="p">[</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">bf_datatype</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Assuming images not read by bio-formats are RGB read using from openslide or png, jpeg, etc...</span>
            <span class="n">np_dtype</span> <span class="o">=</span> <span class="s2">&quot;uint8&quot;</span>

        <span class="n">displacement_gb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="o">*</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">calc_memory_size_gb</span><span class="p">(</span><span class="n">full_out_shape</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="n">processed_img_gb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="o">*</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">calc_memory_size_gb</span><span class="p">(</span><span class="n">out_shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;uint8&quot;</span><span class="p">)</span>
        <span class="n">img_gb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="o">*</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">calc_memory_size_gb</span><span class="p">(</span><span class="n">out_shape</span><span class="p">,</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">np_dtype</span><span class="p">)</span>

        <span class="c1"># Size of full displacement fields, all larger processed images, and an image that will be processed</span>
        <span class="n">estimated_gb</span> <span class="o">=</span> <span class="n">img_gb</span> <span class="o">+</span> <span class="n">displacement_gb</span> <span class="o">+</span> <span class="n">processed_img_gb</span>

        <span class="k">if</span> <span class="n">estimated_gb</span> <span class="o">&gt;</span> <span class="n">TILER_THRESH_GB</span><span class="p">:</span>
            <span class="c1"># Avoid having huge displacement fields saved in registrar. Would make it difficult to open</span>
            <span class="n">use_tiler</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">scaled_warped_img_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="n">scaled_mask_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="n">img_names_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="n">img_f_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">======== Preparing images for non-rigid registraration</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>

            <span class="c1"># Get image to warp. Likely a larger image scaled down to specified shape #</span>
            <span class="n">src_img_shape_rc</span><span class="p">,</span> <span class="n">src_M</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_src_img_shape_and_M</span><span class="p">(</span><span class="n">transformation_src_shape_rc</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                                            <span class="n">transformation_dst_shape_rc</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span>
                                                                            <span class="n">dst_shape_rc</span><span class="o">=</span><span class="n">full_out_shape</span><span class="p">,</span>
                                                                            <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">max_img_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">closest_img_levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">src_img_shape_rc</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest_img_levels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">closest_img_level</span> <span class="o">=</span> <span class="n">closest_img_levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">closest_img_level</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">closest_img_level</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">vips_level_img</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">slide2vips</span><span class="p">(</span><span class="n">closest_img_level</span><span class="p">)</span>
            <span class="n">img_to_warp</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">resize_img</span><span class="p">(</span><span class="n">vips_level_img</span><span class="p">,</span> <span class="n">src_img_shape_rc</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">updating_non_rigid</span><span class="p">:</span>
                <span class="n">dxdy</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">bk_dxdy</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dxdy</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">use_tiler</span><span class="p">:</span>
                <span class="c1"># Process image using same method for rigid registration #</span>
                <span class="n">unprocessed_warped_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">img_to_warp</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                    <span class="n">bk_dxdy</span><span class="o">=</span><span class="n">dxdy</span><span class="p">,</span>
                    <span class="n">transformation_src_shape_rc</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                    <span class="n">transformation_dst_shape_rc</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span>
                    <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">full_out_shape</span><span class="p">,</span>
                    <span class="n">bbox_xywh</span><span class="o">=</span><span class="n">mask_bbox_xywh</span><span class="p">,</span>
                    <span class="n">bg_color</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">bg_color</span><span class="p">)</span>

                <span class="n">temp_processing_mask</span> <span class="o">=</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">black</span><span class="p">(</span><span class="n">img_to_warp</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">img_to_warp</span><span class="o">.</span><span class="n">height</span><span class="p">)</span><span class="o">.</span><span class="n">invert</span><span class="p">()</span>
                <span class="n">processing_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">temp_processing_mask</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                    <span class="n">bk_dxdy</span><span class="o">=</span><span class="n">dxdy</span><span class="p">,</span>
                    <span class="n">transformation_src_shape_rc</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                    <span class="n">transformation_dst_shape_rc</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span>
                    <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">full_out_shape</span><span class="p">,</span>
                    <span class="n">bbox_xywh</span><span class="o">=</span><span class="n">mask_bbox_xywh</span><span class="p">,</span>
                    <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>

                <span class="n">unprocessed_warped_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">unprocessed_warped_img</span><span class="p">)</span>
                <span class="n">processing_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">processing_mask</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">img_type</span> <span class="o">==</span> <span class="n">slide_tools</span><span class="o">.</span><span class="n">IHC_NAME</span><span class="p">:</span>
                    <span class="n">processing_cls</span> <span class="o">=</span> <span class="n">brightfield_processing_cls</span>
                    <span class="n">processing_kwargs</span> <span class="o">=</span> <span class="n">brightfield_processing_kwargs</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">processing_cls</span> <span class="o">=</span> <span class="n">if_processing_cls</span>
                    <span class="n">processing_kwargs</span> <span class="o">=</span> <span class="n">if_processing_kwargs</span>

                <span class="n">processor</span> <span class="o">=</span> <span class="n">processing_cls</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">unprocessed_warped_img</span><span class="p">,</span> <span class="n">src_f</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">src_f</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">closest_img_level</span><span class="p">,</span> <span class="n">series</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">series</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">processed_img</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">process_image</span><span class="p">(</span><span class="o">**</span><span class="n">processing_kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="c1"># processor.process_image doesn&#39;t take kwargs</span>
                    <span class="n">processed_img</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">process_image</span><span class="p">()</span>
                <span class="n">processed_img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">processed_img</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
                <span class="n">processed_img</span><span class="p">[</span><span class="n">processing_mask</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Normalize images using stats collected for rigid registration #</span>
                <span class="n">warped_img</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">norm_img_stats</span><span class="p">(</span><span class="n">processed_img</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_processing_stats</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">processing_mask</span><span class="p">)</span>
                <span class="n">warped_img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">warped_img</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">warp_full_img</span><span class="p">:</span>
                    <span class="n">warped_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">img_to_warp</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                <span class="n">bk_dxdy</span><span class="o">=</span><span class="n">dxdy</span><span class="p">,</span>
                                <span class="n">transformation_src_shape_rc</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                <span class="n">transformation_dst_shape_rc</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">,</span>
                                <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">full_out_shape</span><span class="p">,</span>
                                <span class="n">bbox_xywh</span><span class="o">=</span><span class="n">mask_bbox_xywh</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warped_img</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_slide</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="n">updating_non_rigid</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="n">mask_bbox_xywh</span><span class="p">)</span>

            <span class="c1"># Get mask #</span>
            <span class="n">img_fg</span> <span class="o">=</span>  <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">black</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">invert</span><span class="p">()</span>
            <span class="n">temp_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img_fg</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">)</span>
            <span class="n">vips_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">resize_img</span><span class="p">(</span><span class="n">temp_mask</span><span class="p">,</span> <span class="n">full_out_shape</span><span class="p">,</span> <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vips_mask</span> <span class="o">=</span> <span class="n">vips_mask</span><span class="o">.</span><span class="n">extract_area</span><span class="p">(</span><span class="o">*</span><span class="n">mask_bbox_xywh</span><span class="p">)</span>
                <span class="n">vips_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">vips_micro_reg_mask</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ifthenelse</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">vips_mask</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">use_tiler</span><span class="p">:</span>
                <span class="n">slide_mask</span> <span class="o">=</span> <span class="n">vips_mask</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slide_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">vips_mask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

            <span class="c1"># Update lists</span>
            <span class="n">img_f_list</span><span class="p">[</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">stack_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">src_f</span>
            <span class="n">img_names_list</span><span class="p">[</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">stack_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span>
            <span class="n">scaled_warped_img_list</span><span class="p">[</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">stack_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">warped_img</span>
            <span class="n">scaled_mask_list</span><span class="p">[</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">stack_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">slide_mask</span>


        <span class="n">img_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">serial_non_rigid</span><span class="o">.</span><span class="n">IMG_LIST_KEY</span><span class="p">:</span> <span class="n">scaled_warped_img_list</span><span class="p">,</span>
                    <span class="n">serial_non_rigid</span><span class="o">.</span><span class="n">IMG_F_LIST_KEY</span><span class="p">:</span> <span class="n">img_f_list</span><span class="p">,</span>
                    <span class="n">serial_non_rigid</span><span class="o">.</span><span class="n">MASK_LIST_KEY</span><span class="p">:</span> <span class="n">scaled_mask_list</span><span class="p">,</span>
                    <span class="n">serial_non_rigid</span><span class="o">.</span><span class="n">IMG_NAME_KEY</span><span class="p">:</span> <span class="n">img_names_list</span>
                    <span class="p">}</span>

        <span class="k">if</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">non_rigid_reg_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vips_nr_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">non_rigid_reg_mask</span><span class="p">)</span>
            <span class="n">scaled_non_rigid_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">resize_img</span><span class="p">(</span><span class="n">vips_nr_mask</span><span class="p">,</span> <span class="n">full_out_shape</span><span class="p">,</span> <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">scaled_non_rigid_mask</span> <span class="o">=</span> <span class="n">scaled_non_rigid_mask</span><span class="o">.</span><span class="n">extract_area</span><span class="p">(</span><span class="o">*</span><span class="n">mask_bbox_xywh</span><span class="p">)</span>
                <span class="n">scaled_non_rigid_mask</span><span class="o">=</span>  <span class="p">(</span><span class="n">vips_micro_reg_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ifthenelse</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">scaled_non_rigid_mask</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">use_tiler</span><span class="p">:</span>
                <span class="n">scaled_non_rigid_mask</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">scaled_non_rigid_mask</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scaled_non_rigid_mask</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">final_max_img_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mask_bbox_xywh</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_max_img_dim</span> <span class="o">=</span> <span class="n">max_img_dim</span>

        <span class="k">return</span> <span class="n">img_dict</span><span class="p">,</span> <span class="n">final_max_img_dim</span><span class="p">,</span> <span class="n">scaled_non_rigid_mask</span><span class="p">,</span> <span class="n">full_out_shape</span><span class="p">,</span> <span class="n">mask_bbox_xywh</span>

    <span class="k">def</span> <span class="nf">non_rigid_register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rigid_registrar</span><span class="p">,</span>
        <span class="n">brightfield_processing_cls</span><span class="p">,</span> <span class="n">brightfield_processing_kwargs</span><span class="p">,</span>
        <span class="n">if_processing_cls</span><span class="p">,</span> <span class="n">if_processing_kwargs</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Non-rigidly register slides</span>

<span class="sd">        Non-rigidly register slides after performing rigid registration.</span>
<span class="sd">        Also saves thumbnails of non-rigidly registered images and deformation</span>
<span class="sd">        fields.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rigid_registrar : SerialRigidRegistrar</span>
<span class="sd">            SerialRigidRegistrar object that performed the rigid registration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        non_rigid_registrar : SerialNonRigidRegistrar</span>
<span class="sd">            SerialNonRigidRegistrar object that performed serial</span>
<span class="sd">            non-rigid registration.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ref_slide</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">create_non_rigid_reg_mask</span><span class="p">()</span>
        <span class="n">non_rigid_reg_mask</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">non_rigid_reg_mask</span>
        <span class="n">cropped_mask_shape_rc</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">xy2bbox</span><span class="p">(</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">mask2xy</span><span class="p">(</span><span class="n">non_rigid_reg_mask</span><span class="p">))[</span><span class="mi">2</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">nr_on_scaled_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_processed_image_dim_px</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_non_rigid_registartion_dim_px</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="n">non_rigid_reg_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cropped_mask_shape_rc</span> <span class="o">!=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">nr_on_scaled_img</span><span class="p">:</span>

            <span class="c1"># Use higher resolution and/or roi for non-rigid</span>
            <span class="n">nr_reg_src</span><span class="p">,</span> <span class="n">max_img_dim</span><span class="p">,</span> <span class="n">non_rigid_reg_mask</span><span class="p">,</span> <span class="n">full_out_shape_rc</span><span class="p">,</span> <span class="n">mask_bbox_xywh</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">prep_images_for_large_non_rigid_registration</span><span class="p">(</span><span class="n">max_img_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_non_rigid_registartion_dim_px</span><span class="p">,</span>
                                                                  <span class="n">brightfield_processing_cls</span><span class="o">=</span><span class="n">brightfield_processing_cls</span><span class="p">,</span>
                                                                  <span class="n">brightfield_processing_kwargs</span><span class="o">=</span><span class="n">brightfield_processing_kwargs</span><span class="p">,</span>
                                                                  <span class="n">if_processing_cls</span><span class="o">=</span><span class="n">if_processing_cls</span><span class="p">,</span>
                                                                  <span class="n">if_processing_kwargs</span><span class="o">=</span><span class="n">if_processing_kwargs</span><span class="p">,</span>
                                                                  <span class="n">mask</span><span class="o">=</span><span class="n">non_rigid_reg_mask</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_non_rigid_bbox</span> <span class="o">=</span> <span class="n">mask_bbox_xywh</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_non_rigid_registartion_dim_px</span> <span class="o">=</span> <span class="n">max_img_dim</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nr_reg_src</span> <span class="o">=</span> <span class="n">rigid_registrar</span>
            <span class="n">full_out_shape_rc</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">reg_img_shape_rc</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">_full_displacement_shape_rc</span> <span class="o">=</span> <span class="n">full_out_shape_rc</span>
        <span class="n">non_rigid_registrar</span> <span class="o">=</span> <span class="n">serial_non_rigid</span><span class="o">.</span><span class="n">register_images</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">nr_reg_src</span><span class="p">,</span>
                                                               <span class="n">mask</span><span class="o">=</span><span class="n">non_rigid_reg_mask</span><span class="p">,</span>
                                                               <span class="n">align_to_reference</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">align_to_reference</span><span class="p">,</span>
                                                               <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_reg_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_non_rigid_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span>  <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_dst_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deformation_field_dir</span><span class="p">]:</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar</span> <span class="o">=</span> <span class="n">non_rigid_registrar</span>


        <span class="c1"># Clean up displacements and expand if mask was used</span>
        <span class="k">for</span> <span class="n">nr_name</span><span class="p">,</span> <span class="n">nr_obj</span> <span class="ow">in</span> <span class="n">non_rigid_registrar</span><span class="o">.</span><span class="n">non_rigid_obj_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">nr_on_scaled_img</span><span class="p">:</span>
                <span class="c1"># If a mask was used, the displacement fields will be smaller</span>
                <span class="c1"># So need to insert them in the full image</span>
                <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_displacement</span><span class="p">(</span><span class="n">nr_obj</span><span class="o">.</span><span class="n">bk_dxdy</span><span class="p">,</span> <span class="n">full_out_shape_rc</span><span class="p">,</span> <span class="n">mask_bbox_xywh</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">nr_obj</span><span class="o">.</span><span class="n">bk_dxdy</span>

            <span class="n">rigid_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_dict</span><span class="p">[</span><span class="n">nr_name</span><span class="p">]</span>
            <span class="n">cleaned_bk_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">remove_invasive_displacements</span><span class="p">(</span><span class="n">bk_dxdy</span><span class="p">,</span>
                                                                    <span class="n">M</span><span class="o">=</span><span class="n">rigid_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                                    <span class="n">src_shape_rc</span><span class="o">=</span><span class="n">rigid_obj</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span>
                                                                    <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">rigid_obj</span><span class="o">.</span><span class="n">registered_shape_rc</span><span class="p">)</span>

            <span class="n">cleaned_fwd_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_inverse_field</span><span class="p">(</span><span class="n">cleaned_bk_dxdy</span><span class="p">)</span>

            <span class="n">nr_obj</span><span class="o">.</span><span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">cleaned_bk_dxdy</span>
            <span class="n">nr_obj</span><span class="o">.</span><span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="n">cleaned_fwd_dxdy</span>

        <span class="c1"># Draw overlap image #</span>
        <span class="n">overlap_mask</span><span class="p">,</span> <span class="n">overlap_mask_bbox_xywh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crop_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">)</span>
        <span class="n">overlap_mask_bbox_xywh</span> <span class="o">=</span> <span class="n">overlap_mask_bbox_xywh</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">nr_on_scaled_img</span><span class="p">:</span>
            <span class="n">non_rigid_img_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">nr_img_obj</span><span class="o">.</span><span class="n">registered_img</span> <span class="k">for</span> <span class="n">nr_img_obj</span> <span class="ow">in</span> <span class="n">non_rigid_registrar</span><span class="o">.</span><span class="n">non_rigid_obj_list</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">non_rigid_img_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">warp_tools</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">o</span><span class="o">.</span><span class="n">image</span><span class="p">,</span>
                                                    <span class="n">M</span><span class="o">=</span><span class="n">o</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                    <span class="n">bk_dxdy</span><span class="o">=</span> <span class="n">non_rigid_registrar</span><span class="o">.</span><span class="n">non_rigid_obj_dict</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">bk_dxdy</span><span class="p">,</span>
                                                    <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">o</span><span class="o">.</span><span class="n">registered_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span>
                                                    <span class="n">transformation_src_shape_rc</span><span class="o">=</span><span class="n">o</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span>
                                                    <span class="n">transformation_dst_shape_rc</span><span class="o">=</span><span class="n">o</span><span class="o">.</span><span class="n">registered_img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
                                                <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_list</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_overlap_img</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_overlap_img</span><span class="p">(</span><span class="n">non_rigid_img_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_overlap_img</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">crop_img</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_overlap_img</span><span class="p">,</span> <span class="n">overlap_mask_bbox_xywh</span><span class="p">)</span>

        <span class="n">overlap_img_fout</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_non_rigid_overlap.png&quot;</span><span class="p">)</span>
        <span class="n">warp_tools</span><span class="o">.</span><span class="n">save_img</span><span class="p">(</span><span class="n">overlap_img_fout</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_overlap_img</span><span class="p">,</span> <span class="n">thumbnail_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="p">)</span>

        <span class="n">n_digits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">slide_name</span><span class="p">,</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># slide_name = &quot;401427_BrdU&quot;</span>
            <span class="c1"># slide_obj = self.slide_dict[slide_name]</span>

            <span class="n">img_save_id</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">stack_idx</span><span class="p">),</span> <span class="n">n_digits</span><span class="p">)</span>
            <span class="n">slide_nr_reg_obj</span> <span class="o">=</span> <span class="n">non_rigid_registrar</span><span class="o">.</span><span class="n">non_rigid_obj_dict</span><span class="p">[</span><span class="n">slide_name</span><span class="p">]</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">slide_nr_reg_obj</span><span class="o">.</span><span class="n">bk_dxdy</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="n">slide_nr_reg_obj</span><span class="o">.</span><span class="n">fwd_dxdy</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">nr_rigid_reg_img_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_dst_dir</span><span class="p">,</span> <span class="n">img_save_id</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">is_rgb</span><span class="p">:</span>
                <span class="n">img_to_warp</span> <span class="o">=</span> <span class="n">rigid_registrar</span><span class="o">.</span><span class="n">img_obj_dict</span><span class="p">[</span><span class="n">slide_name</span><span class="p">]</span><span class="o">.</span><span class="n">image</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">img_to_warp</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span>

            <span class="n">warped_img</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img_to_warp</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">)</span>
            <span class="n">warp_tools</span><span class="o">.</span><span class="n">save_img</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">nr_rigid_reg_img_f</span><span class="p">,</span> <span class="n">warped_img</span><span class="p">,</span> <span class="n">thumbnail_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="p">)</span>

            <span class="c1"># Draw displacements on image actually used in non-rigid. Might be higher resolution</span>
            <span class="n">draw_dxdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">slide_nr_reg_obj</span><span class="o">.</span><span class="n">bk_dxdy</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nr_on_scaled_img</span><span class="p">:</span>
                <span class="n">draw_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">crop_img</span><span class="p">(</span><span class="n">draw_dxdy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_non_rigid_bbox</span><span class="p">)</span>

            <span class="n">thumbnail_scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">draw_dxdy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">thumbnail_bk_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_thumbnail</span><span class="p">(</span><span class="n">draw_dxdy</span><span class="p">)</span>
            <span class="n">thumbnail_bk_dxdy</span> <span class="o">*=</span> <span class="n">thumbnail_scaling</span>

            <span class="n">draw_img</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">slide_nr_reg_obj</span><span class="o">.</span><span class="n">registered_img</span><span class="p">,</span>
                            <span class="n">thumbnail_bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                            <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">slide_nr_reg_obj</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">draw_img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">draw_img</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">draw_img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">draw_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">draw_img</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>


            <span class="n">thumbanil_deform_grid</span> <span class="o">=</span> <span class="n">viz</span><span class="o">.</span><span class="n">color_displacement_tri_grid</span><span class="p">(</span><span class="n">bk_dx</span><span class="o">=</span><span class="n">thumbnail_bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                                    <span class="n">bk_dy</span><span class="o">=</span><span class="n">thumbnail_bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                                                    <span class="n">img</span><span class="o">=</span><span class="n">draw_img</span><span class="p">,</span>
                                                                    <span class="n">n_grid_pts</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>

            <span class="n">deform_img_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deformation_field_dir</span><span class="p">,</span> <span class="n">img_save_id</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span><span class="p">)</span>
            <span class="n">warp_tools</span><span class="o">.</span><span class="n">save_img</span><span class="p">(</span><span class="n">deform_img_f</span><span class="p">,</span> <span class="n">thumbanil_deform_grid</span><span class="p">,</span> <span class="n">thumbnail_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">non_rigid_registrar</span>

    <span class="k">def</span> <span class="nf">measure_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Measure registration error</span>

<span class="sd">        Error is measured as the distance between matched features</span>
<span class="sd">        after registration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary_df : Dataframe</span>
<span class="sd">            `summary_df` contains various information about the registration.</span>

<span class="sd">            The &quot;from&quot; column is the name of the image, while the &quot;to&quot; column</span>
<span class="sd">            name of the image it was aligned to. &quot;from&quot; is analagous to &quot;moving&quot;</span>
<span class="sd">            or &quot;current&quot;, while &quot;to&quot; is analgous to &quot;fixed&quot; or &quot;previous&quot;.</span>

<span class="sd">            Columns begining with &quot;original&quot; refer to error measurements of the</span>
<span class="sd">            unregistered images. Those beginning with &quot;rigid&quot; or &quot;non_rigid&quot; refer</span>
<span class="sd">            to measurements related to rigid or non-rigid registration, respectively.</span>

<span class="sd">            Columns beginning with &quot;mean&quot; are averages of error measurements. In</span>
<span class="sd">            the case of errors based on feature distances (i.e. those ending in &quot;D&quot;),</span>
<span class="sd">            the mean is weighted by the number of feature matches between &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            Columns endining in &quot;D&quot; indicate the median distance between matched</span>
<span class="sd">            features in &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            Columns ending in &quot;rTRE&quot; indicate the target registration error between</span>
<span class="sd">            &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            Columns ending in &quot;mattesMI&quot; contain measurements of the Mattes mutual</span>
<span class="sd">            information between &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            &quot;processed_img_shape&quot; indicates the shape (row, column) of the processed</span>
<span class="sd">            image actually used to conduct the registration</span>

<span class="sd">            &quot;shape&quot; is the shape of the slide at full resolution</span>

<span class="sd">            &quot;aligned_shape&quot; is the shape of the registered full resolution slide</span>

<span class="sd">            &quot;physical_units&quot; are the names of the pixels physcial unit, e.g. u&#39;\u00B5m&#39;</span>

<span class="sd">            &quot;resolution&quot; is the physical unit per pixel</span>

<span class="sd">            &quot;name&quot; is the name assigned to the Valis instance</span>

<span class="sd">            &quot;rigid_time_minutes&quot; is the total number of minutes it took</span>
<span class="sd">            to convert the images and then rigidly align them.</span>

<span class="sd">            &quot;non_rigid_time_minutes&quot; is the total number of minutes it took</span>
<span class="sd">            to convert the images, and then perform rigid -&gt; non-rigid registration.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">path_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">all_og_d</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">all_og_tre</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="n">all_rigid_d</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">all_rigid_tre</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="n">all_nr_d</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">all_nr_tre</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="n">all_n</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">from_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">to_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">shape_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">processed_img_shape_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">unit_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">resolution_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="n">slide_obj_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">outshape</span> <span class="o">=</span> <span class="n">slide_obj_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span>

        <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ref_slide</span><span class="p">()</span>
        <span class="n">ref_diagonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">stack_idx</span>
            <span class="n">slide_name</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span>

            <span class="n">shape_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_shape_rc</span><span class="p">)</span>
            <span class="n">processed_img_shape_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">)</span>
            <span class="n">unit_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">units</span>
            <span class="n">resolution_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">resolution</span>
            <span class="n">from_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">slide_name</span>
            <span class="n">path_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">src_f</span>

            <span class="k">if</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">prev_slide_obj</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">fixed_slide</span>
            <span class="n">to_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">name</span>

            <span class="n">img_T</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_padding_matrix</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                  <span class="n">slide_obj</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">)</span>

            <span class="n">prev_T</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_padding_matrix</span><span class="p">(</span><span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                   <span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">)</span>


            <span class="n">prev_kp_in_slide</span> <span class="o">=</span> <span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_in_prev</span><span class="p">,</span>
                                                     <span class="n">M</span><span class="o">=</span><span class="n">prev_T</span><span class="p">,</span>
                                                     <span class="n">pt_level</span><span class="o">=</span> <span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                     <span class="n">non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">current_kp_in_slide</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_matched_to_prev</span><span class="p">,</span>
                                                    <span class="n">M</span><span class="o">=</span><span class="n">img_T</span><span class="p">,</span>
                                                    <span class="n">pt_level</span><span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                    <span class="n">non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">og_d</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">calc_d</span><span class="p">(</span><span class="n">prev_kp_in_slide</span><span class="p">,</span> <span class="n">current_kp_in_slide</span><span class="p">)</span>

            <span class="n">og_rtre</span> <span class="o">=</span> <span class="n">og_d</span><span class="o">/</span><span class="n">ref_diagonal</span>
            <span class="n">median_og_tre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">og_rtre</span><span class="p">)</span>
            <span class="n">og_d</span> <span class="o">*=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">resolution</span>
            <span class="n">median_d_og</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">og_d</span><span class="p">)</span>

            <span class="n">all_og_d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">median_d_og</span>
            <span class="n">all_og_tre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">median_og_tre</span>


            <span class="n">prev_warped_rigid</span> <span class="o">=</span> <span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_in_prev</span><span class="p">,</span>
                                                       <span class="n">M</span><span class="o">=</span><span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                       <span class="n">pt_level</span><span class="o">=</span> <span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                       <span class="n">non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">current_warped_rigid</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_matched_to_prev</span><span class="p">,</span>
                                                     <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                     <span class="n">pt_level</span><span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                     <span class="n">non_rigid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


            <span class="n">rigid_d</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">calc_d</span><span class="p">(</span><span class="n">prev_warped_rigid</span><span class="p">,</span> <span class="n">current_warped_rigid</span><span class="p">)</span>
            <span class="n">rtre</span> <span class="o">=</span> <span class="n">rigid_d</span><span class="o">/</span><span class="n">ref_diagonal</span>
            <span class="n">median_rigid_tre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">rtre</span><span class="p">)</span>
            <span class="n">rigid_d</span> <span class="o">*=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">resolution</span>
            <span class="n">median_d_rigid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">rigid_d</span><span class="p">)</span>

            <span class="n">all_rigid_d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">median_d_rigid</span>
            <span class="n">all_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rigid_d</span><span class="p">)</span>
            <span class="n">all_rigid_tre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">median_rigid_tre</span>

            <span class="k">if</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">bk_dxdy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>


                <span class="n">prev_warped_nr</span> <span class="o">=</span> <span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_in_prev</span><span class="p">,</span>
                                                        <span class="n">M</span><span class="o">=</span><span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                        <span class="n">pt_level</span><span class="o">=</span> <span class="n">prev_slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                        <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">current_warped_nr</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_xy</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">xy_matched_to_prev</span><span class="p">,</span>
                                                      <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                      <span class="n">pt_level</span><span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                      <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">nr_d</span> <span class="o">=</span>  <span class="n">warp_tools</span><span class="o">.</span><span class="n">calc_d</span><span class="p">(</span><span class="n">prev_warped_nr</span><span class="p">,</span> <span class="n">current_warped_nr</span><span class="p">)</span>
                <span class="n">nrtre</span> <span class="o">=</span> <span class="n">nr_d</span><span class="o">/</span><span class="n">ref_diagonal</span>
                <span class="n">mean_nr_tre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">nrtre</span><span class="p">)</span>

                <span class="n">nr_d</span> <span class="o">*=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">resolution</span>
                <span class="n">median_d_nr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">nr_d</span><span class="p">)</span>
                <span class="n">all_nr_d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">median_d_nr</span>
                <span class="n">all_nr_tre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_nr_tre</span>


        <span class="n">non_ref_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">non_ref_idx</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_img_idx</span><span class="p">)</span>

        <span class="n">non_ref_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_n</span><span class="p">)[</span><span class="n">non_ref_idx</span><span class="p">]</span>
        <span class="n">mean_og_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_og_d</span><span class="p">)[</span><span class="n">non_ref_idx</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">non_ref_weights</span><span class="p">)</span>
        <span class="n">median_og_tre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_og_tre</span><span class="p">)[</span><span class="n">non_ref_idx</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">non_ref_weights</span><span class="p">)</span>

        <span class="n">mean_rigid_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_rigid_d</span><span class="p">)[</span><span class="n">non_ref_idx</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">non_ref_weights</span><span class="p">)</span>
        <span class="n">median_rigid_tre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_rigid_tre</span><span class="p">)[</span><span class="n">non_ref_idx</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">non_ref_weights</span><span class="p">)</span>

        <span class="n">rigid_min</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_rigid_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span><span class="o">/</span><span class="mi">60</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">summary_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s2">&quot;filename&quot;</span><span class="p">:</span> <span class="n">path_list</span><span class="p">,</span>
            <span class="s2">&quot;from&quot;</span><span class="p">:</span><span class="n">from_list</span><span class="p">,</span>
            <span class="s2">&quot;to&quot;</span><span class="p">:</span> <span class="n">to_list</span><span class="p">,</span>
            <span class="s2">&quot;original_D&quot;</span><span class="p">:</span> <span class="n">all_og_d</span><span class="p">,</span>
            <span class="s2">&quot;original_rTRE&quot;</span><span class="p">:</span> <span class="n">all_og_tre</span><span class="p">,</span>
            <span class="s2">&quot;rigid_D&quot;</span><span class="p">:</span> <span class="n">all_rigid_d</span><span class="p">,</span>
            <span class="s2">&quot;rigid_rTRE&quot;</span><span class="p">:</span> <span class="n">all_rigid_tre</span><span class="p">,</span>
            <span class="s2">&quot;non_rigid_D&quot;</span><span class="p">:</span> <span class="n">all_nr_d</span><span class="p">,</span>
            <span class="s2">&quot;non_rigid_rTRE&quot;</span><span class="p">:</span> <span class="n">all_rigid_tre</span><span class="p">,</span>
            <span class="s2">&quot;processed_img_shape&quot;</span><span class="p">:</span> <span class="n">processed_img_shape_list</span><span class="p">,</span>
            <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="n">shape_list</span><span class="p">,</span>
            <span class="s2">&quot;aligned_shape&quot;</span><span class="p">:</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">outshape</span><span class="p">)]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
            <span class="s2">&quot;mean_original_D&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">mean_og_d</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
            <span class="s2">&quot;mean_rigid_D&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">mean_rigid_d</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
            <span class="s2">&quot;physical_units&quot;</span><span class="p">:</span><span class="n">unit_list</span><span class="p">,</span>
            <span class="s2">&quot;resolution&quot;</span><span class="p">:</span><span class="n">resolution_list</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
            <span class="s2">&quot;rigid_time_minutes&quot;</span> <span class="p">:</span> <span class="p">[</span><span class="n">rigid_min</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="p">})</span>

        <span class="k">if</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">bk_dxdy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mean_nr_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_nr_d</span><span class="p">)[</span><span class="n">non_ref_idx</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">non_ref_weights</span><span class="p">)</span>
            <span class="n">mean_nr_tre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_nr_tre</span><span class="p">)[</span><span class="n">non_ref_idx</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">non_ref_weights</span><span class="p">)</span>
            <span class="n">non_rigid_min</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_non_rigid_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span><span class="o">/</span><span class="mi">60</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">summary_df</span><span class="p">[</span><span class="s2">&quot;mean_non_rigid_D&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">mean_nr_d</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">summary_df</span><span class="p">[</span><span class="s2">&quot;non_rigid_time_minutes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">non_rigid_min</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">summary_df</span>

<div class="viewcode-block" id="Valis.register"><a class="viewcode-back" href="../../registration.html#valis.registration.Valis.register">[docs]</a>    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">brightfield_processing_cls</span><span class="o">=</span><span class="n">DEFAULT_BRIGHTFIELD_CLASS</span><span class="p">,</span>
                 <span class="n">brightfield_processing_kwargs</span><span class="o">=</span><span class="n">DEFAULT_BRIGHTFIELD_PROCESSING_ARGS</span><span class="p">,</span>
                 <span class="n">if_processing_cls</span><span class="o">=</span><span class="n">DEFAULT_FLOURESCENCE_CLASS</span><span class="p">,</span>
                 <span class="n">if_processing_kwargs</span><span class="o">=</span><span class="n">DEFAULT_FLOURESCENCE_PROCESSING_ARGS</span><span class="p">,</span>
                 <span class="n">reader_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Register a collection of images</span>

<span class="sd">        This function will convert the slides to images, pre-process and normalize them, and</span>
<span class="sd">        then conduct rigid registration. Non-rigid registration will then be performed if the</span>
<span class="sd">        `non_rigid_registrar_cls` argument used to initialize the Valis object was not None.</span>

<span class="sd">        In addition to the objects returned, the desination directory (i.e. `dst_dir`)</span>
<span class="sd">        will contain thumbnails so that one can visualize the results: converted image</span>
<span class="sd">        thumbnails will be in &quot;images/&quot;; processed images in &quot;processed/&quot;;</span>
<span class="sd">        rigidly aligned images in &quot;rigid_registration/&quot;; non-rigidly aligned images in &quot;non_rigid_registration/&quot;;</span>
<span class="sd">        non-rigid deformation field images (i.e. warped grids colored by the direction and magntidue)</span>
<span class="sd">        of the deformation) will be in &quot;&quot;deformation_fields/&quot;. The size of these thumbnails</span>
<span class="sd">        is determined by the `thumbnail_size` argument used to initialze this object.</span>

<span class="sd">        One can get a sense of how well the registration worked by looking</span>
<span class="sd">        in the &quot;overlaps/&quot;, which shows how the images overlap before</span>
<span class="sd">        registration, after rigid registration, and after non-rigid registration. Each image</span>
<span class="sd">        is created by coloring an inverted greyscale version of the processed images, and then</span>
<span class="sd">        blending those images.</span>

<span class="sd">        The &quot;data/&quot; directory will contain a pickled copy of this registrar, which can be</span>
<span class="sd">        later be opened (unpickled) and used to warp slides and/or point data.</span>

<span class="sd">        &quot;data/&quot; will also contain the `summary_df` saved as a csv file.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        brightfield_processing_cls : preprocessing.ImageProcesser</span>
<span class="sd">            preprocessing.ImageProcesser used to pre-process brightfield images to make</span>
<span class="sd">            them look as similar as possible.</span>

<span class="sd">        brightfield_processing_kwargs : dict</span>
<span class="sd">            Dictionary of keyward arguments to be passed to `brightfield_processing_cls`</span>

<span class="sd">        if_processing_cls : preprocessing.ImageProcesser</span>
<span class="sd">            preprocessing.ImageProcesser used to pre-process immunofluorescent images</span>
<span class="sd">            to make them look as similar as possible.</span>

<span class="sd">        if_processing_kwargs : dict</span>
<span class="sd">            Dictionary of keyward arguments to be passed to `if_processing_cls`</span>

<span class="sd">        reader_cls : SlideReader, optional</span>
<span class="sd">            Uninstantiated SlideReader class that will convert</span>
<span class="sd">            the slide to an image, and also collect metadata. If None (the default),</span>
<span class="sd">            the appropriate SlideReader will be found by `slide_io.get_slide_reader`.</span>
<span class="sd">            This option is provided in case the slides cannot be opened by a current</span>
<span class="sd">            SlideReader class. In this case, the user should create a subclass of</span>
<span class="sd">            SlideReader. See slide_io.SlideReader for details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rigid_registrar : SerialRigidRegistrar</span>
<span class="sd">            SerialRigidRegistrar object that performed the rigid registration.</span>
<span class="sd">            This object can be pickled if so desired</span>

<span class="sd">        non_rigid_registrar : SerialNonRigidRegistrar</span>
<span class="sd">            SerialNonRigidRegistrar object that performed serial</span>
<span class="sd">            non-rigid registration. This object can be pickled if so desired.</span>

<span class="sd">        summary_df : Dataframe</span>
<span class="sd">            `summary_df` contains various information about the registration.</span>

<span class="sd">            The &quot;from&quot; column is the name of the image, while the &quot;to&quot; column</span>
<span class="sd">            name of the image it was aligned to. &quot;from&quot; is analagous to &quot;moving&quot;</span>
<span class="sd">            or &quot;current&quot;, while &quot;to&quot; is analgous to &quot;fixed&quot; or &quot;previous&quot;.</span>

<span class="sd">            Columns begining with &quot;original&quot; refer to error measurements of the</span>
<span class="sd">            unregistered images. Those beginning with &quot;rigid&quot; or &quot;non_rigid&quot; refer</span>
<span class="sd">            to measurements related to rigid or non-rigid registration, respectively.</span>

<span class="sd">            Columns beginning with &quot;mean&quot; are averages of error measurements. In</span>
<span class="sd">            the case of errors based on feature distances (i.e. those ending in &quot;D&quot;),</span>
<span class="sd">            the mean is weighted by the number of feature matches between &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            Columns endining in &quot;D&quot; indicate the median distance between matched</span>
<span class="sd">            features in &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            Columns ending in &quot;TRE&quot; indicate the target registration error between</span>
<span class="sd">            &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            Columns ending in &quot;mattesMI&quot; contain measurements of the Mattes mutual</span>
<span class="sd">            information between &quot;from&quot; and &quot;to&quot;.</span>

<span class="sd">            &quot;processed_img_shape&quot; indicates the shape (row, column) of the processed</span>
<span class="sd">            image actually used to conduct the registration</span>

<span class="sd">            &quot;shape&quot; is the shape of the slide at full resolution</span>

<span class="sd">            &quot;aligned_shape&quot; is the shape of the registered full resolution slide</span>

<span class="sd">            &quot;physical_units&quot; are the names of the pixels physcial unit, e.g. u&#39;\u00B5m&#39;</span>

<span class="sd">            &quot;resolution&quot; is the physical unit per pixel</span>

<span class="sd">            &quot;name&quot; is the name assigned to the Valis instance</span>

<span class="sd">            &quot;rigid_time_minutes&quot; is the total number of minutes it took</span>
<span class="sd">            to convert the images and then rigidly align them.</span>

<span class="sd">            &quot;non_rigid_time_minutes&quot; is the total number of minutes it took</span>
<span class="sd">            to convert the images, and then perform rigid -&gt; non-rigid registration.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==== Converting images</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">convert_imgs</span><span class="p">(</span><span class="n">series</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">,</span> <span class="n">reader_cls</span><span class="o">=</span><span class="n">reader_cls</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==== Processing images</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">brightfield_procsseing_fxn_str</span> <span class="o">=</span> <span class="n">brightfield_processing_cls</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">if_processing_fxn_str</span> <span class="o">=</span> <span class="n">if_processing_cls</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_imgs</span><span class="p">(</span><span class="n">brightfield_processing_cls</span><span class="p">,</span> <span class="n">brightfield_processing_kwargs</span><span class="p">,</span>
                              <span class="n">if_processing_cls</span><span class="p">,</span> <span class="n">if_processing_kwargs</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==== Rigid registraration</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">rigid_registrar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rigid_register</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">rigid_registrar</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==== Non-rigid registraration</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">non_rigid_registrar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_register</span><span class="p">(</span><span class="n">rigid_registrar</span><span class="p">,</span>
                    <span class="n">brightfield_processing_cls</span><span class="o">=</span><span class="n">brightfield_processing_cls</span><span class="p">,</span>
                    <span class="n">brightfield_processing_kwargs</span><span class="o">=</span><span class="n">brightfield_processing_kwargs</span><span class="p">,</span>
                    <span class="n">if_processing_cls</span><span class="o">=</span><span class="n">if_processing_cls</span><span class="p">,</span>
                    <span class="n">if_processing_kwargs</span><span class="o">=</span><span class="n">if_processing_kwargs</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">non_rigid_registrar</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==== Measuring error</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">aligned_slide_shape_rc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_aligned_slide_shape</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span> <span class="o">=</span> <span class="n">aligned_slide_shape_rc</span>
            <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">slide_obj</span><span class="o">.</span><span class="n">aligned_slide_shape_rc</span> <span class="o">=</span> <span class="n">aligned_slide_shape_rc</span>

            <span class="n">error_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_error</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>

            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">f_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_registrar.pickle&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reg_f</span> <span class="o">=</span> <span class="n">f_out</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">f_out</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">))</span>

            <span class="n">data_f_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_summary.csv&quot;</span><span class="p">)</span>
            <span class="n">error_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">data_f_out</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">())</span>
            <span class="n">kill_jvm</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>


        <span class="k">return</span> <span class="n">rigid_registrar</span><span class="p">,</span> <span class="n">non_rigid_registrar</span><span class="p">,</span> <span class="n">error_df</span></div>

    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove objects that can&#39;t be pickled</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="s2">&quot;feature_detector&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_reg_kwargs</span><span class="p">[</span><span class="s2">&quot;affine_optimizer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar_cls</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rigid_registrar</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_rigid_registrar</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">register_micro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>  <span class="n">brightfield_processing_cls</span><span class="o">=</span><span class="n">DEFAULT_BRIGHTFIELD_CLASS</span><span class="p">,</span>
                 <span class="n">brightfield_processing_kwargs</span><span class="o">=</span><span class="n">DEFAULT_BRIGHTFIELD_PROCESSING_ARGS</span><span class="p">,</span>
                 <span class="n">if_processing_cls</span><span class="o">=</span><span class="n">DEFAULT_FLOURESCENCE_CLASS</span><span class="p">,</span>
                 <span class="n">if_processing_kwargs</span><span class="o">=</span><span class="n">DEFAULT_FLOURESCENCE_PROCESSING_ARGS</span><span class="p">,</span>
                 <span class="n">max_non_rigid_registartion_dim_px</span><span class="o">=</span><span class="n">DEFAULT_MAX_NON_RIGID_REG_SIZE</span><span class="p">,</span>
                 <span class="n">non_rigid_registrar_cls</span><span class="o">=</span><span class="n">DEFAULT_NON_RIGID_CLASS</span><span class="p">,</span>
                 <span class="n">non_rigid_reg_params</span><span class="o">=</span><span class="n">DEFAULT_NON_RIGID_KWARGS</span><span class="p">,</span>
                 <span class="n">reference_img_f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">align_to_reference</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tile_wh</span><span class="o">=</span><span class="n">DEFAULT_NR_TILE_WH</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Improve alingment of microfeatures by performing second non-rigid registration on larger images</span>

<span class="sd">        Caclculates additional non-rigid deformations using a larger image</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        brightfield_processing_cls : preprocessing.ImageProcesser</span>
<span class="sd">            preprocessing.ImageProcesser used to pre-process brightfield images to make</span>
<span class="sd">            them look as similar as possible.</span>

<span class="sd">        brightfield_processing_kwargs : dict</span>
<span class="sd">            Dictionary of keyward arguments to be passed to `brightfield_processing_cls`</span>

<span class="sd">        if_processing_cls : preprocessing.ImageProcesser</span>
<span class="sd">            preprocessing.ImageProcesser used to pre-process immunofluorescent images</span>
<span class="sd">            to make them look as similar as possible.</span>

<span class="sd">        if_processing_kwargs : dict</span>
<span class="sd">            Dictionary of keyward arguments to be passed to `if_processing_cls`</span>

<span class="sd">        max_non_rigid_registartion_dim_px : int, optional</span>
<span class="sd">             Maximum width or height of images used for non-rigid registration.</span>
<span class="sd">             If None, then the full sized image will be used. However, this</span>
<span class="sd">             may take quite some time to complete.</span>

<span class="sd">        reference_img_f : str, optional</span>
<span class="sd">            Filename of image that will be treated as the center of the stack.</span>
<span class="sd">            If None, the index of the middle image will be the reference, and</span>
<span class="sd">            images will be aligned towards it. If provided, images will be</span>
<span class="sd">            aligned to this reference.</span>

<span class="sd">        align_to_reference : bool, optional</span>
<span class="sd">            If `False`, images will be non-rigidly aligned serially towards the</span>
<span class="sd">            reference image. If `True`, images will be non-rigidly aligned</span>
<span class="sd">            directly to the reference image. If `reference_img_f` is None,</span>
<span class="sd">            then the reference image will be the one in the middle of the stack.</span>

<span class="sd">        non_rigid_registrar_cls : NonRigidRegistrar, optional</span>
<span class="sd">            Uninstantiated NonRigidRegistrar class that will be used to</span>
<span class="sd">            calculate the deformation fields between images. See</span>
<span class="sd">            the `non_rigid_registrars` module for a desciption of available</span>
<span class="sd">            methods. If a desired non-rigid registration method is not available,</span>
<span class="sd">            one can be implemented by subclassing.NonRigidRegistrar.</span>

<span class="sd">        non_rigid_reg_params: dictionary, optional</span>
<span class="sd">            Dictionary containing key, value pairs to be used to initialize</span>
<span class="sd">            `non_rigid_registrar_cls`.</span>
<span class="sd">            In the case where simple ITK is used by the, params should be</span>
<span class="sd">            a SimpleITK.ParameterMap. Note that numeric values nedd to be</span>
<span class="sd">            converted to strings. See the NonRigidRegistrar classes in</span>
<span class="sd">            `non_rigid_registrars` for the available non-rigid registration</span>
<span class="sd">            methods and arguments.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ref_slide</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">non_rigid_reg_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">non_rigid_reg_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">nr_reg_src</span><span class="p">,</span> <span class="n">max_img_dim</span><span class="p">,</span> <span class="n">non_rigid_reg_mask</span><span class="p">,</span> <span class="n">full_out_shape_rc</span><span class="p">,</span> <span class="n">mask_bbox_xywh</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">prep_images_for_large_non_rigid_registration</span><span class="p">(</span><span class="n">max_img_dim</span><span class="o">=</span><span class="n">max_non_rigid_registartion_dim_px</span><span class="p">,</span>
                                                                <span class="n">brightfield_processing_cls</span><span class="o">=</span><span class="n">brightfield_processing_cls</span><span class="p">,</span>
                                                                <span class="n">brightfield_processing_kwargs</span><span class="o">=</span><span class="n">brightfield_processing_kwargs</span><span class="p">,</span>
                                                                <span class="n">if_processing_cls</span><span class="o">=</span><span class="n">if_processing_cls</span><span class="p">,</span>
                                                                <span class="n">if_processing_kwargs</span><span class="o">=</span><span class="n">if_processing_kwargs</span><span class="p">,</span>
                                                                <span class="n">updating_non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="n">img0</span> <span class="o">=</span> <span class="n">nr_reg_src</span><span class="p">[</span><span class="n">serial_non_rigid</span><span class="o">.</span><span class="n">IMG_LIST_KEY</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">img_specific_args</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">write_dxdy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_non_rigid_bbox</span> <span class="o">=</span> <span class="n">mask_bbox_xywh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_full_displacement_shape_rc</span> <span class="o">=</span> <span class="n">full_out_shape_rc</span>



        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img0</span><span class="p">,</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>

            <span class="c1"># Have determined that these images will be too big</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Registration would more than </span><span class="si">{</span><span class="n">TILER_THRESH_GB</span><span class="si">}</span><span class="s2"> GB if all images opened in memory. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Will use NonRigidTileRegistrar to register cooresponding tiles to reduce memory consumption, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;but this method is experimental&quot;</span><span class="p">)</span>

            <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="n">write_dxdy</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">img_specific_args</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>

                <span class="c1"># Add registration parameters</span>
                <span class="n">tiled_non_rigid_reg_params</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">tiled_non_rigid_reg_params</span><span class="p">[</span><span class="n">non_rigid_registrars</span><span class="o">.</span><span class="n">NR_CLS_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">non_rigid_registrar_cls</span>
                <span class="n">tiled_non_rigid_reg_params</span><span class="p">[</span><span class="n">non_rigid_registrars</span><span class="o">.</span><span class="n">NR_STATS_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_processing_stats</span>
                <span class="n">tiled_non_rigid_reg_params</span><span class="p">[</span><span class="n">non_rigid_registrars</span><span class="o">.</span><span class="n">NR_TILE_WH_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile_wh</span>

                <span class="k">if</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">is_rgb</span><span class="p">:</span>
                    <span class="n">processing_cls</span> <span class="o">=</span> <span class="n">brightfield_processing_cls</span>
                    <span class="n">processing_args</span> <span class="o">=</span> <span class="n">brightfield_processing_kwargs</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">processing_cls</span> <span class="o">=</span> <span class="n">if_processing_cls</span>
                    <span class="n">processing_args</span> <span class="o">=</span> <span class="n">if_processing_kwargs</span>

                <span class="n">tiled_non_rigid_reg_params</span><span class="p">[</span><span class="n">non_rigid_registrars</span><span class="o">.</span><span class="n">NR_PROCESSING_CLASS_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">processing_cls</span>
                <span class="n">tiled_non_rigid_reg_params</span><span class="p">[</span><span class="n">non_rigid_registrars</span><span class="o">.</span><span class="n">NR_PROCESSING_KW_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="n">processing_args</span>

                <span class="n">img_specific_args</span><span class="p">[</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">src_f</span><span class="p">]</span> <span class="o">=</span> <span class="n">tiled_non_rigid_reg_params</span>

            <span class="n">non_rigid_registrar_cls</span> <span class="o">=</span> <span class="n">non_rigid_registrars</span><span class="o">.</span><span class="n">NonRigidTileRegistrar</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==== Performing microregistration</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">non_rigid_registrar</span> <span class="o">=</span> <span class="n">serial_non_rigid</span><span class="o">.</span><span class="n">register_images</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">nr_reg_src</span><span class="p">,</span>
                                                               <span class="n">non_rigid_reg_class</span><span class="o">=</span><span class="n">non_rigid_registrar_cls</span><span class="p">,</span>
                                                               <span class="n">non_rigid_reg_params</span><span class="o">=</span><span class="n">non_rigid_reg_params</span><span class="p">,</span>
                                                               <span class="n">reference_img_f</span><span class="o">=</span><span class="n">reference_img_f</span><span class="p">,</span>
                                                               <span class="n">mask</span><span class="o">=</span><span class="n">non_rigid_reg_mask</span><span class="p">,</span>
                                                               <span class="n">align_to_reference</span><span class="o">=</span><span class="n">align_to_reference</span><span class="p">,</span>
                                                               <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                                               <span class="n">img_params</span><span class="o">=</span><span class="n">img_specific_args</span>
                                                               <span class="p">)</span>

        <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">micro_reg_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">out_shape</span> <span class="o">=</span> <span class="n">full_out_shape_rc</span>
        <span class="n">n_digits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">micro_reg_imgs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>

        <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>

            <span class="n">nr_obj</span> <span class="o">=</span> <span class="n">non_rigid_registrar</span><span class="o">.</span><span class="n">non_rigid_obj_dict</span><span class="p">[</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="n">is_array</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nr_obj</span><span class="o">.</span><span class="n">bk_dxdy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>
                <span class="n">is_array</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">cleaned_bk_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">remove_invasive_displacements</span><span class="p">(</span><span class="n">nr_obj</span><span class="o">.</span><span class="n">bk_dxdy</span><span class="p">,</span>
                                                                    <span class="n">M</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">M</span><span class="p">,</span>
                                                                    <span class="n">src_shape_rc</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">,</span>
                                                                    <span class="n">out_shape_rc</span><span class="o">=</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">)</span>
                <span class="n">cleaned_fwd_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">get_inverse_field</span><span class="p">(</span><span class="n">cleaned_bk_dxdy</span><span class="p">)</span>

                <span class="n">new_bk_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">cleaned_bk_dxdy</span><span class="p">))</span>
                <span class="n">new_fwd_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">cleaned_fwd_dxdy</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_bk_dxdy</span> <span class="o">=</span> <span class="n">nr_obj</span><span class="o">.</span><span class="n">bk_dxdy</span>
                <span class="n">new_fwd_dxdy</span> <span class="o">=</span> <span class="n">nr_obj</span><span class="o">.</span><span class="n">fwd_dxdy</span>


            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">non_rigid_registrar</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">full_out_shape_rc</span><span class="p">):</span>
                <span class="c1"># Micro-registration perfomred on sub-region. Need to put in full image</span>
                <span class="n">new_bk_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_displacement</span><span class="p">(</span><span class="n">new_bk_dxdy</span><span class="p">,</span> <span class="n">full_out_shape_rc</span><span class="p">,</span> <span class="n">mask_bbox_xywh</span><span class="p">)</span>
                <span class="n">new_fwd_dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_displacement</span><span class="p">(</span><span class="n">new_fwd_dxdy</span><span class="p">,</span> <span class="n">full_out_shape_rc</span><span class="p">,</span> <span class="n">mask_bbox_xywh</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">bk_dxdy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pyvips</span><span class="o">.</span><span class="n">Image</span><span class="p">):</span>
                <span class="n">current_bk_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">bk_dxdy</span><span class="p">))</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
                <span class="n">current_fwd_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">numpy2vips</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">fwd_dxdy</span><span class="p">))</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_bk_dxdy</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">bk_dxdy</span>
                <span class="n">current_fwd_dxdy</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">fwd_dxdy</span>

            <span class="n">slide_sxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">current_bk_dxdy</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">current_bk_dxdy</span><span class="o">.</span><span class="n">width</span><span class="p">]))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">slide_sxy</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">scaled_bk_dx</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">slide_sxy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">current_bk_dxdy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">scaled_bk_dy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">slide_sxy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">current_bk_dxdy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">current_bk_dxdy</span> <span class="o">=</span> <span class="n">scaled_bk_dx</span><span class="o">.</span><span class="n">bandjoin</span><span class="p">(</span><span class="n">scaled_bk_dy</span><span class="p">)</span>
                <span class="n">current_bk_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">resize_img</span><span class="p">(</span><span class="n">current_bk_dxdy</span><span class="p">,</span> <span class="n">out_shape</span><span class="p">)</span>

                <span class="n">scaled_fwd_dx</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">slide_sxy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">current_fwd_dxdy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">scaled_fwd_dy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">slide_sxy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">current_fwd_dxdy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">current_fwd_dxdy</span> <span class="o">=</span> <span class="n">scaled_fwd_dx</span><span class="o">.</span><span class="n">bandjoin</span><span class="p">(</span><span class="n">scaled_fwd_dy</span><span class="p">)</span>
                <span class="n">current_fwd_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">resize_img</span><span class="p">(</span><span class="n">current_fwd_dxdy</span><span class="p">,</span> <span class="n">out_shape</span><span class="p">)</span>

            <span class="n">updated_bk_dxdy</span> <span class="o">=</span> <span class="n">current_bk_dxdy</span> <span class="o">+</span> <span class="n">new_bk_dxdy</span>
            <span class="n">updated_fwd_dxdy</span> <span class="o">=</span> <span class="n">current_fwd_dxdy</span> <span class="o">+</span> <span class="n">new_fwd_dxdy</span>

            <span class="k">if</span> <span class="n">is_array</span><span class="p">:</span>
                <span class="n">updated_bk_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">updated_bk_dxdy</span><span class="p">)</span>
                <span class="n">updated_fwd_dxdy</span> <span class="o">=</span> <span class="n">warp_tools</span><span class="o">.</span><span class="n">vips2numpy</span><span class="p">(</span><span class="n">updated_fwd_dxdy</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">write_dxdy</span><span class="p">:</span>
                <span class="n">slide_obj</span><span class="o">.</span><span class="n">bk_dxdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">updated_bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">updated_bk_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
                <span class="n">slide_obj</span><span class="o">.</span><span class="n">fwd_dxdy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">updated_fwd_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">updated_fwd_dxdy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">displacements_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">slide_obj</span><span class="o">.</span><span class="n">stored_dxdy</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">bk_dxdy_f</span><span class="p">,</span> <span class="n">fwd_dxdy_f</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">get_displacement_f</span><span class="p">()</span>
                <span class="n">slide_obj</span><span class="o">.</span><span class="n">_bk_dxdy_f</span> <span class="o">=</span> <span class="n">bk_dxdy_f</span>
                <span class="n">slide_obj</span><span class="o">.</span><span class="n">_fwd_dxdy_f</span> <span class="o">=</span> <span class="n">fwd_dxdy_f</span>

                <span class="c1"># Save space by only writing the necessary areas. Most displacements may be 0</span>
                <span class="n">cropped_bk_dxdy</span> <span class="o">=</span> <span class="n">updated_bk_dxdy</span><span class="o">.</span><span class="n">extract_area</span><span class="p">(</span><span class="o">*</span><span class="n">mask_bbox_xywh</span><span class="p">)</span>
                <span class="n">cropped_fwd_dxdy</span> <span class="o">=</span> <span class="n">updated_fwd_dxdy</span><span class="o">.</span><span class="n">extract_area</span><span class="p">(</span><span class="o">*</span><span class="n">mask_bbox_xywh</span><span class="p">)</span>

                <span class="n">cropped_bk_dxdy</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tiffsave</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">_bk_dxdy_f</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;lzw&quot;</span><span class="p">,</span> <span class="n">lossless</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tile</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bigtiff</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">cropped_fwd_dxdy</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tiffsave</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">_fwd_dxdy_f</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;lzw&quot;</span><span class="p">,</span> <span class="n">lossless</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tile</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bigtiff</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">is_rgb</span><span class="p">:</span>
                <span class="n">img_to_warp</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">img_to_warp</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">image</span>

            <span class="n">micro_reg_img</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">img_to_warp</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crop</span><span class="p">)</span>


            <span class="n">img_save_id</span> <span class="o">=</span> <span class="nb">str</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">stack_idx</span><span class="p">),</span> <span class="n">n_digits</span><span class="p">)</span>
            <span class="n">micro_fout</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">micro_reg_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">img_save_id</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">)</span>
            <span class="n">micro_thumb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_thumbnail</span><span class="p">(</span><span class="n">micro_reg_img</span><span class="p">)</span>
            <span class="n">warp_tools</span><span class="o">.</span><span class="n">save_img</span><span class="p">(</span><span class="n">micro_fout</span><span class="p">,</span> <span class="n">micro_thumb</span><span class="p">)</span>

            <span class="n">processed_micro_reg_img</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_img</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">processed_img</span><span class="p">)</span>
            <span class="n">micro_reg_imgs</span><span class="p">[</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">stack_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">processed_micro_reg_img</span>

        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reg_f</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">))</span>

        <span class="n">micro_overlap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_overlap_img</span><span class="p">(</span><span class="n">micro_reg_imgs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">micro_reg_overlap_img</span> <span class="o">=</span> <span class="n">micro_overlap</span>
        <span class="n">overlap_img_fout</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_micro_reg.png&quot;</span><span class="p">)</span>
        <span class="n">warp_tools</span><span class="o">.</span><span class="n">save_img</span><span class="p">(</span><span class="n">overlap_img_fout</span><span class="p">,</span> <span class="n">micro_overlap</span><span class="p">,</span> <span class="n">thumbnail_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thumbnail_size</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==== Measuring error</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">error_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_error</span><span class="p">()</span>
        <span class="n">data_f_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_summary.csv&quot;</span><span class="p">)</span>
        <span class="n">error_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">data_f_out</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">non_rigid_registrar</span><span class="p">,</span> <span class="n">error_df</span>



    <span class="k">def</span> <span class="nf">get_aligned_slide_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get size of aligned images</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int, float</span>
<span class="sd">            If `level` is an integer, then it is assumed that `level` is referring to</span>
<span class="sd">            the pyramid level that will be warped.</span>

<span class="sd">            If `level` is a float, it is assumed `level` is how much to rescale the</span>
<span class="sd">            registered image&#39;s size.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ref_slide</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ref_slide</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">level</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">n_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;=</span> <span class="n">n_levels</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;requested to scale transformation for pyramid level </span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s2">, &quot;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;but the image only has </span><span class="si">{</span><span class="n">n_levels</span><span class="si">}</span><span class="s2"> (starting from 0). &quot;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;Will use level </span><span class="si">{</span><span class="n">level</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">, which is the smallest level&quot;</span><span class="p">)</span>
                <span class="n">valtils</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">slide_shape_rc</span> <span class="o">=</span> <span class="n">ref_slide</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="n">level</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">s_rc</span> <span class="o">=</span> <span class="p">(</span><span class="n">slide_shape_rc</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">processed_img_shape_rc</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s_rc</span> <span class="o">=</span> <span class="n">level</span>

        <span class="n">aligned_out_shape_rc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref_slide</span><span class="o">.</span><span class="n">reg_img_shape_rc</span><span class="p">)</span><span class="o">*</span><span class="n">s_rc</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">aligned_out_shape_rc</span>

<div class="viewcode-block" id="Valis.get_slide"><a class="viewcode-back" href="../../registration.html#valis.registration.Valis.get_slide">[docs]</a>    <span class="k">def</span> <span class="nf">get_slide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get Slide</span>

<span class="sd">        Get the Slide associated with `src_f`.</span>
<span class="sd">        Slide store registration parameters and other metadata about</span>
<span class="sd">        the slide associated with `src_f`. Slide can also:</span>

<span class="sd">        * Convert the slide to a numpy array (Slide.slide2image)</span>
<span class="sd">        * Convert the slide to a pyvips.Image (Slide.slide2vips)</span>
<span class="sd">        * Warp the slide (Slide.warp_slide)</span>
<span class="sd">        * Save the warped slide as an ome.tiff (Slide.warp_and_save_slide)</span>
<span class="sd">        * Warp an image of the slide (Slide.warp_img)</span>
<span class="sd">        * Warp points (Slide.warp_xy)</span>
<span class="sd">        * Warp points in one slide to their position in another unwarped slide (Slide.warp_xy_from_to)</span>
<span class="sd">        * Access slide ome-xml (Slide.original_xml)</span>

<span class="sd">        See Slide for more details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_f : str</span>
<span class="sd">            Path to the slide</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        slide_obj : Slide</span>
<span class="sd">            Slide associated with src_f</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">slide_name</span> <span class="o">=</span> <span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">src_f</span><span class="p">)</span>
        <span class="n">slide_obj</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">slide_name</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">slide_obj</span></div>

    <span class="nd">@valtils</span><span class="o">.</span><span class="n">deprecated_args</span><span class="p">(</span><span class="n">crop_to_overlap</span><span class="o">=</span><span class="s2">&quot;crop&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">warp_and_save_slides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dst_dir</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">perceputally_uniform_channel_colors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;bicubic&quot;</span><span class="p">,</span>
                             <span class="n">tile_wh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;lzw&quot;</span><span class="p">):</span>

        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;Warp and save all slides</span>

<span class="s2">        Each slide will be saved as an ome.tiff. The extension of each file will</span>
<span class="s2">        be changed to ome.tiff if it is not already.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        dst_dir : str</span>
<span class="s2">            Path to were the warped slides will be saved.</span>

<span class="s2">        level : int, optional</span>
<span class="s2">            Pyramid level to be warped. Default is 0, which means the highest</span>
<span class="s2">            resolution image will be warped and saved.</span>

<span class="s2">        non_rigid : bool, optional</span>
<span class="s2">            Whether or not to conduct non-rigid warping. If False,</span>
<span class="s2">            then only a rigid transformation will be applied. Default is True</span>

<span class="s2">        crop: bool, str</span>
<span class="s2">            How to crop the registered images. If `True`, then the same crop used</span>
<span class="s2">            when initializing the `Valis` object will be used. If `False`, the</span>
<span class="s2">            image will not be cropped. If &quot;overlap&quot;, the warped slide will be</span>
<span class="s2">            cropped to include only areas where all images overlapped.</span>
<span class="s2">            &quot;reference&quot; crops to the area that overlaps with the reference image,</span>
<span class="s2">            defined by `reference_img_f` when initialzing the `Valis object`.</span>

<span class="s2">        interp_method : str</span>
<span class="s2">            Interpolation method used when warping slide. Default is &quot;bicubic&quot;</span>

<span class="s2">        tile_wh : int, optional</span>
<span class="s2">            Tile width and height used to save image</span>

<span class="s2">        compression : str, optional</span>
<span class="s2">            Compression method used to save ome.tiff . Default is lzw, but can also</span>
<span class="s2">            be jpeg or jp2k. See pyips for more details.</span>

<span class="s2">        &quot;&quot;&quot;</span>
        <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">dst_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">slide_obj</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">dst_f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dst_dir</span><span class="p">,</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.ome.tiff&quot;</span><span class="p">)</span>
            <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_and_save_slide</span><span class="p">(</span><span class="n">dst_f</span><span class="o">=</span><span class="n">dst_f</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">,</span>
                                          <span class="n">non_rigid</span><span class="o">=</span><span class="n">non_rigid</span><span class="p">,</span>
                                          <span class="n">crop</span><span class="o">=</span><span class="n">crop</span><span class="p">,</span>
                                          <span class="n">perceputally_uniform_channel_colors</span><span class="o">=</span><span class="n">perceputally_uniform_channel_colors</span><span class="p">,</span>
                                          <span class="n">interp_method</span><span class="o">=</span><span class="n">interp_method</span><span class="p">,</span>
                                          <span class="n">tile_wh</span><span class="o">=</span><span class="n">tile_wh</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span>

<div class="viewcode-block" id="Valis.warp_and_merge_slides"><a class="viewcode-back" href="../../registration.html#valis.registration.Valis.warp_and_merge_slides">[docs]</a>    <span class="nd">@valtils</span><span class="o">.</span><span class="n">deprecated_args</span><span class="p">(</span><span class="n">crop_to_overlap</span><span class="o">=</span><span class="s2">&quot;crop&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">warp_and_merge_slides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dst_f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">channel_name_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">src_f_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">perceputally_uniform_channel_colors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">drop_duplicates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tile_wh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">interp_method</span><span class="o">=</span><span class="s2">&quot;bicubic&quot;</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;lzw&quot;</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Warp and merge registered slides</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dst_f : str, optional</span>
<span class="sd">            Path to were the warped slide will be saved. If None, then the slides will be merged</span>
<span class="sd">            but not saved.</span>

<span class="sd">        level : int, optional</span>
<span class="sd">            Pyramid level to be warped. Default is 0, which means the highest</span>
<span class="sd">            resolution image will be warped and saved.</span>

<span class="sd">        non_rigid : bool, optional</span>
<span class="sd">            Whether or not to conduct non-rigid warping. If False,</span>
<span class="sd">            then only a rigid transformation will be applied. Default is True</span>

<span class="sd">        crop: bool, str</span>
<span class="sd">            How to crop the registered images. If `True`, then the same crop used</span>
<span class="sd">            when initializing the `Valis` object will be used. If `False`, the</span>
<span class="sd">            image will not be cropped. If &quot;overlap&quot;, the warped slide will be</span>
<span class="sd">            cropped to include only areas where all images overlapped.</span>
<span class="sd">            &quot;reference&quot; crops to the area that overlaps with the reference image,</span>
<span class="sd">            defined by `reference_img_f` when initialzing the `Valis object`.</span>

<span class="sd">        channel_name_dict : dict of lists, optional.</span>
<span class="sd">            key =  slide file name, value = list of channel names for that slide. If None,</span>
<span class="sd">            the the channel names found in each slide will be used.</span>

<span class="sd">        src_f_list : list of str, optionaal</span>
<span class="sd">            List of paths to slide to be warped. If None (the default), Valis.original_img_list</span>
<span class="sd">            will be used. Otherwise, the paths to which `src_f_list` points to should</span>
<span class="sd">            be an alternative copy of the slides, such as ones that have undergone</span>
<span class="sd">            processing (e.g. stain segmentation), had a mask applied, etc...</span>

<span class="sd">        perceputally_uniform_channel_colors : bool, optional</span>
<span class="sd">            Whether or not to add perceptually uniform channel colors.</span>

<span class="sd">        drop_duplicates : bool, optional</span>
<span class="sd">            Whether or not to drop duplicate channels that might be found in multiple slides.</span>
<span class="sd">            For example, if DAPI is in multiple slides, then the only the DAPI channel in the</span>
<span class="sd">            first slide will be kept.</span>

<span class="sd">        tile_wh : int, optional</span>
<span class="sd">            Tile width and height used to save image</span>

<span class="sd">        interp_method : str</span>
<span class="sd">            Interpolation method used when warping slide. Default is &quot;bicubic&quot;</span>

<span class="sd">        compression : str</span>
<span class="sd">            Compression method used to save ome.tiff . Default is lzw, but can also</span>
<span class="sd">            be jpeg or jp2k. See pyips for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged_slide : pyvips.Image</span>
<span class="sd">            Image with all channels merged. If `drop_duplicates` is True, then this</span>
<span class="sd">            will only contain unique channels.</span>

<span class="sd">        all_channel_names : list of str</span>
<span class="sd">            Name of each channel in the image</span>

<span class="sd">        ome_xml : str</span>
<span class="sd">            OME-XML string containing the slide&#39;s metadata</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">channel_name_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channel_name_dict_by_name</span> <span class="o">=</span> <span class="p">{</span><span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">k</span><span class="p">):</span><span class="n">channel_name_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">channel_name_dict</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">src_f_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">src_f_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_img_list</span>

        <span class="n">all_channel_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">merged_slide</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">src_f_list</span><span class="p">:</span>
            <span class="n">slide_name</span> <span class="o">=</span> <span class="n">valtils</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">slide_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide_dict</span><span class="p">[</span><span class="n">slide_name</span><span class="p">]</span>

            <span class="n">warped_slide</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">warp_slide</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">non_rigid</span><span class="o">=</span><span class="n">non_rigid</span><span class="p">,</span>
                                                <span class="n">crop</span><span class="o">=</span><span class="n">crop</span><span class="p">,</span>
                                                <span class="n">interp_method</span><span class="o">=</span><span class="n">interp_method</span><span class="p">)</span>

            <span class="n">keep_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">warped_slide</span><span class="o">.</span><span class="n">bands</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">channel_name_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">slide_channel_names</span> <span class="o">=</span> <span class="n">channel_name_dict_by_name</span><span class="p">[</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">drop_duplicates</span><span class="p">:</span>
                    <span class="n">keep_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span>  <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slide_channel_names</span><span class="p">))</span> <span class="k">if</span>
                                <span class="n">slide_channel_names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_channel_names</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">slide_channel_names</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">channel_names</span>
                <span class="n">slide_channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="s2">&quot; (&quot;</span> <span class="o">+</span> <span class="n">slide_name</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span>  <span class="n">slide_channel_names</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">drop_duplicates</span> <span class="ow">and</span> <span class="n">warped_slide</span><span class="o">.</span><span class="n">bands</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_idx</span><span class="p">):</span>
                <span class="n">keep_channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">warped_slide</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">keep_idx</span><span class="p">]</span>
                <span class="n">slide_channel_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">slide_channel_names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">keep_idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep_channels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">warped_slide</span> <span class="o">=</span> <span class="n">keep_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warped_slide</span> <span class="o">=</span> <span class="n">keep_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bandjoin</span><span class="p">(</span><span class="n">keep_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;merging </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">slide_channel_names</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">merged_slide</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">merged_slide</span> <span class="o">=</span> <span class="n">warped_slide</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_slide</span> <span class="o">=</span> <span class="n">merged_slide</span><span class="o">.</span><span class="n">bandjoin</span><span class="p">(</span><span class="n">warped_slide</span><span class="p">)</span>

            <span class="n">all_channel_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">slide_channel_names</span><span class="p">)</span>


        <span class="n">px_phys_size</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">scale_physical_size</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="n">bf_dtype</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">vips2bf_dtype</span><span class="p">(</span><span class="n">merged_slide</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
        <span class="n">out_xyczt</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">get_shape_xyzct</span><span class="p">((</span><span class="n">merged_slide</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">merged_slide</span><span class="o">.</span><span class="n">height</span><span class="p">),</span> <span class="n">merged_slide</span><span class="o">.</span><span class="n">bands</span><span class="p">)</span>
        <span class="n">ome_xml_obj</span> <span class="o">=</span> <span class="n">slide_io</span><span class="o">.</span><span class="n">create_ome_xml</span><span class="p">(</span><span class="n">out_xyczt</span><span class="p">,</span> <span class="n">bf_dtype</span><span class="p">,</span> <span class="n">is_rgb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                              <span class="n">pixel_physical_size_xyu</span><span class="o">=</span><span class="n">px_phys_size</span><span class="p">,</span>
                                              <span class="n">channel_names</span><span class="o">=</span><span class="n">all_channel_names</span><span class="p">,</span>
                                              <span class="n">perceputally_uniform_channel_colors</span><span class="o">=</span><span class="n">perceputally_uniform_channel_colors</span><span class="p">)</span>
        <span class="n">ome_xml</span> <span class="o">=</span> <span class="n">ome_xml_obj</span><span class="o">.</span><span class="n">to_xml</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">dst_f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dst_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dst_f</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">dst_dir</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tile_wh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tile_wh</span> <span class="o">=</span> <span class="n">slide_obj</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">optimal_tile_wh</span>
                <span class="k">if</span> <span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">down_sampling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">/</span><span class="n">slide_obj</span><span class="o">.</span><span class="n">slide_dimensions_wh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">tile_wh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">tile_wh</span><span class="o">*</span><span class="n">down_sampling</span><span class="p">))</span>
                    <span class="n">tile_wh</span> <span class="o">=</span> <span class="n">tile_wh</span> <span class="o">-</span> <span class="p">(</span><span class="n">tile_wh</span> <span class="o">%</span> <span class="mi">16</span><span class="p">)</span>  <span class="c1"># Tile shape must be multiple of 16</span>
                    <span class="k">if</span> <span class="n">tile_wh</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">:</span>
                        <span class="n">tile_wh</span> <span class="o">=</span> <span class="mi">16</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_xyczt</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tile_wh</span><span class="p">):</span>
                        <span class="n">tile_wh</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">out_xyczt</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>

            <span class="n">slide_io</span><span class="o">.</span><span class="n">save_ome_tiff</span><span class="p">(</span><span class="n">merged_slide</span><span class="p">,</span> <span class="n">dst_f</span><span class="o">=</span><span class="n">dst_f</span><span class="p">,</span>
                                   <span class="n">ome_xml</span><span class="o">=</span><span class="n">ome_xml</span><span class="p">,</span><span class="n">tile_wh</span><span class="o">=</span><span class="n">tile_wh</span><span class="p">,</span>
                                   <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_slide</span><span class="p">,</span> <span class="n">all_channel_names</span><span class="p">,</span> <span class="n">ome_xml</span></div></div>

</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Chandler Gatenbee.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>